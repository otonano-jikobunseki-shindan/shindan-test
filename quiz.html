<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>大人の診断テスト</title>
　<style>
  :root {
    /* 信頼感と優しさを両立するパレット */
    --bg1: #fffaf7;    /* 暖かみのある白 */
    --bg2: #fff0eb;    /* 柔らかいピーチ */
    --card: #ffffff;
    --text: #443d3a;   /* 柔らかい濃茶 */
    --muted: #8e847e;  /* 落ち着いたベージュグレー */
    --accent: #ff8a6b;  /* 安心感のあるコーラル */
    --accent-light: #fff0eb;
    --accent2: #6bc2a5; /* 優しいミントグリーン */
    --line: #eee0d9;
    --shadow: 0 12px 30px rgba(180, 140, 120, 0.12);
    --shadow-sm: 0 4px 12px rgba(180, 140, 120, 0.08);
    --radius: 24px;
    --radius-sm: 16px;
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    margin: 0;
    font-family: "Hiragino Maru Gothic ProN", "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
    background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
    background-attachment: fixed;
    color: var(--text);
    line-height: 1.6;
  }

  .wrap {
    max-width: 500px; /* スマホで見やすい幅に凝縮 */
    margin: 0 auto;
    padding: 24px 16px 60px;
  }

  /* ヒーローエリア：よりウェルカムな印象に */
  .hero {
    padding: 32px 24px;
    border: none;
    border-radius: var(--radius);
    background: rgba(255, 255, 255, 0.9);
    box-shadow: var(--shadow);
    backdrop-filter: blur(8px);
    text-align: center;
    margin-bottom: 24px;
  }

  h1 {
    font-size: 20px;
    margin: 0 0 12px;
    color: var(--text);
    line-height: 1.4;
    font-weight: 800;
  }

  .sub {
    color: var(--muted);
    font-size: 14px;
    margin: 0;
  }

  /* カードデザイン：枠線をなくし、柔らかい影で浮き立たせる */
  .card {
    margin-top: 16px;
    padding: 24px;
    border: none;
    border-radius: var(--radius);
    background: var(--card);
    box-shadow: var(--shadow);
  }

  .row { display: flex; gap: 12px; flex-wrap: wrap; }

  /* ボタン：角丸を強調し、立体感のあるグラデーションに */
  .btn {
    appearance: none;
    border: 2px solid var(--line);
    background: #fff;
    color: var(--text);
    padding: 14px 20px;
    border-radius: 999px; /* 完全に丸く */
    font-weight: 700;
    font-size: 15px;
    cursor: pointer;
    flex: 1;
    min-width: 120px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .btn:active { transform: scale(0.96); }

  .btn.primary {
    background: linear-gradient(135deg, #ff9a7b 0%, #ff7a59 100%);
    border: none;
    color: #fff;
    box-shadow: 0 6px 20px rgba(255, 122, 89, 0.3);
  }

  .btn.good {
    background: linear-gradient(135deg, #7bcea6 0%, #5ab68e 100%);
    border: none;
    color: #fff;
    box-shadow: 0 6px 20px rgba(90, 182, 142, 0.2);
  }

  .btn.ghost {
    background: transparent;
    border: none;
    color: var(--muted);
    text-decoration: underline;
    box-shadow: none;
  }

  .btn.danger {
    background: #fff5f5;
    border: 1px solid #fed7d7;
    color: #c53030;
    box-shadow: none;
  }

  .btn:disabled { opacity: 0.4; filter: grayscale(1); }

  /* プログレスバー：太くして「進んでいる感」を出す */
  .label {
    font-size: 13px;
    font-weight: 700;
    color: var(--muted);
    margin-bottom: 8px;
    display: block;
  }

  .progress {
    height: 12px;
    background: #fdf2ef;
    border-radius: 999px;
    overflow: hidden;
    margin-bottom: 24px;
  }

  .bar {
    height: 100%;
    background: linear-gradient(90deg, #ff9a7b, #6bc2a5);
    border-radius: 999px;
    transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  /* 質問ブロック：カード間の余白を広げ、視認性を向上 */
  .qblock {
    border: none;
    border-radius: var(--radius);
    padding: 24px;
    margin: 24px 0;
    background: #fff;
    box-shadow: var(--shadow-sm);
  }

  .qnum {
    font-size: 12px;
    color: var(--accent);
    background: var(--accent-light);
    padding: 2px 10px;
    border-radius: 999px;
    display: inline-block;
    margin-bottom: 12px;
  }

  .qtitle {
    font-size: 17px;
    font-weight: 800;
    margin: 0 0 16px;
    line-height: 1.5;
  }

  /* 選択肢ボタン：より「押しやすい」デザインに */
  .opt {
    display: block;
    width: 100%;
    text-align: left;
    margin: 12px 0;
    padding: 16px;
    border-radius: var(--radius-sm);
    border: 2px solid #fdf2ef;
    background: #fff;
    color: var(--text);
    font-size: 15px;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .opt:hover { background: #fffaf9; border-color: var(--accent); }

  .opt.selected {
    background: var(--accent-light);
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 4px 12px rgba(255, 122, 89, 0.1);
  }

  .pill {
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 11px;
    background: #fff;
    border: 1px solid var(--line);
    color: var(--muted);
  }

  .field {
    width: 100%;
    padding: 14px;
    border-radius: var(--radius-sm);
    border: 2px solid var(--line);
    font-size: 16px;
    margin-bottom: 12px;
  }

  .mutedBox {
    background: #fdfaf8;
    border: 1px dashed var(--line);
    padding: 16px;
    border-radius: var(--radius-sm);
    color: var(--muted);
    font-size: 13px;
  }

  .tiny { font-size: 12px; opacity: 0.8; }
  .hr { height: 1px; background: var(--line); margin: 24px 0; opacity: 0.5; }
　</style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>あなたの特性が笑っちゃうほどわかる！大人の診断テスト！</h1>
      <p class="sub">5分以内で回答できる！現在、完全無料で診断できます。</p>
      <p class="sub tiny">※このページはスマホ前提で作っていますが、PCでも表示可能です。</p>
    </div>

    <div id="app" class="card"></div>

    <div class="card">
      <div class="label">デバッグ表示（必要なときだけ見る用）</div>
      <div class="mutedBox tiny">
        sessionId: <span id="dbgSid" class="mono"></span><br/>
        step: <span id="dbgStep" class="mono"></span>
      </div>
    </div>
  </div>

<script>
/* =========================
   Config
========================= */
const GAS_URL = "https://script.google.com/macros/s/AKfycbz0nSbcIZKV6P3d8NPu1mZKRjVLT2EF6grR5nfc2otxiky6jdaRBiFhskvjoemWUlOn/exec";
const NEXT_PAGE_URL = "name.html";

// GAS actions
const ACTIONS = {
  LOG: "logAnswer",
  BATCH: "logAnswersBatch",
  // ★追加（集計開始シグナル）
  START_AGG: "startAggregate",
};

const TSV_PATH = {
  male: "data/male_questions.tsv",
  female: "data/female_questions.tsv",
  mbti: "data/mbti_options.tsv"
};

// 10問ずつ
const PAGE_SIZE = 10;

// 10秒停止で途中送信
const IDLE_SEND_MS = 10_000;

const LS = {
  gender: "diag_gender",
  sid: "diag_sid",
  answers: "diag_answers",
  progress: "diag_progress",
  sent: "diag_sent",          // 送信済みqid一覧
};

let runtime = {
  step: "landing",
  sid: "",
  gender: "",
  questions: [],
  // idx: 0,10,20...
  idx: 0,
  answers: {},
  mbtiOptions: null,

  // 送信済み判定（qid -> true）
  sentMap: {},

  // 送信中ロック
  inflight: false,

  // ★追加：裏送信用ロック（UIは止めない）
  bgInflight: false,

  // アイドルタイマー
  idleTimer: null,
  lastActivityAt: 0,

  // ★追加：handoff多重遷移防止
  handoffTimer: null,
  handoffBusy: false,
};

const $app = document.getElementById("app");
const $dbgSid = document.getElementById("dbgSid");
const $dbgStep = document.getElementById("dbgStep");

/* =========================
   Utils
========================= */
function setStep(step){ runtime.step = step; render(); }
function escapeHTML(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function nowISO(){ return new Date().toISOString(); }
function newSessionId(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "sid_" + Date.now() + "_" + Math.random().toString(16).slice(2);
}
function optStr(n){ return "OPT" + String(n); }
function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

/* =========================
   ★改良：確実に「ページ最上部」へスクロール
   - iOS含め効くように scrollTop を複数経路で0に
========================= */
function scrollToPageTop_(){
  try{
    // 即時
    window.scrollTo(0, 0);
    if (document.documentElement) document.documentElement.scrollTop = 0;
    if (document.body) document.body.scrollTop = 0;

    // DOM反映後にも叩く（レンダー直後に効かない端末対策）
    requestAnimationFrame(() => {
      window.scrollTo(0, 0);
      if (document.documentElement) document.documentElement.scrollTop = 0;
      if (document.body) document.body.scrollTop = 0;
      requestAnimationFrame(() => {
        window.scrollTo(0, 0);
        if (document.documentElement) document.documentElement.scrollTop = 0;
        if (document.body) document.body.scrollTop = 0;
      });
    });
  }catch(_){}
}

/* =========================
   ★改良：ページ遷移後に「裏で送信」する（UIを止めない）
   - targets を事前に確定して送るので idx が変わってもOK
========================= */
function sendTargetsInBackground_(targets){
  try{
    if (!targets || targets.length === 0) return;
    if (runtime.bgInflight) return; // 多重発火を抑止（最低限）
    runtime.bgInflight = true;

    (async () => {
      try{
        const payload = {
          action: ACTIONS.BATCH,
          sessionId: runtime.sid,
          gender: runtime.gender,
          answeredAt: nowISO(),
          answers: targets
        };
        const r = await postGAS(payload);
        if (r && r.ok){
          targets.forEach(x => { if (x && x.qid) runtime.sentMap[x.qid] = true; });
          saveLS();
        }
      }catch(_){
        // 失敗しても「未送信」のまま残るので、次の送信チャンスで回収できる
      }finally{
        runtime.bgInflight = false;
      }
    })();
  }catch(_){}
}

/* =========================
   ★改良：「最初からやり直す」でも性別は維持
   - gender は残す
   - questions も維持（空なら gender から再読込）
========================= */
async function restartFromBeginningKeepGender_(){
  const g = runtime.gender || localStorage.getItem(LS.gender) || "";
  runtime.gender = g;

  runtime.sid = newSessionId();
  runtime.idx = 0;
  runtime.answers = {};
  runtime.sentMap = {};
  runtime.inflight = false;

  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);
  runtime.idleTimer = null;

  // answers/progress/sent は消す（genderは消さない）
  localStorage.removeItem(LS.answers);
  localStorage.removeItem(LS.progress);
  localStorage.removeItem(LS.sent);
  localStorage.setItem(LS.gender, runtime.gender);

  // questions が無ければ gender から再読込（TSVありません問題の回避）
  if (!runtime.questions || runtime.questions.length === 0){
    if (runtime.gender){
      runtime.questions = await loadTSV(runtime.gender === "male" ? TSV_PATH.male : TSV_PATH.female);
    }
  }

  saveLS();
}

/* =========================
   LocalStorage
========================= */
function loadLS(){
  const sid = localStorage.getItem(LS.sid);
  const gender = localStorage.getItem(LS.gender);
  const answersRaw = localStorage.getItem(LS.answers);
  const progressRaw = localStorage.getItem(LS.progress);
  const sentRaw = localStorage.getItem(LS.sent);

  if (sid) runtime.sid = sid;
  if (gender) runtime.gender = gender;

  if (answersRaw){
    try{ runtime.answers = JSON.parse(answersRaw) || {}; }catch(_){}
  }
  if (progressRaw){
    try{
      const p = JSON.parse(progressRaw) || {};
      runtime.idx = Number(p.idx || 0);
    }catch(_){}
  }
  if (sentRaw){
    try{ runtime.sentMap = JSON.parse(sentRaw) || {}; }catch(_){}
  }
}

function saveLS(){
  localStorage.setItem(LS.sid, runtime.sid);
  localStorage.setItem(LS.gender, runtime.gender);
  localStorage.setItem(LS.answers, JSON.stringify(runtime.answers || {}));
  localStorage.setItem(LS.progress, JSON.stringify({ idx: runtime.idx, savedAt: nowISO() }));
  localStorage.setItem(LS.sent, JSON.stringify(runtime.sentMap || {}));
}

function clearLSForRestart(){
  localStorage.removeItem(LS.gender);
  localStorage.removeItem(LS.sid);
  localStorage.removeItem(LS.answers);
  localStorage.removeItem(LS.progress);
  localStorage.removeItem(LS.sent);
}

/* =========================
   TSV
========================= */
async function loadTSV(path){
  const res = await fetch(path, { cache:"no-store" });
  if (!res.ok) throw new Error(`TSV読込に失敗: ${path}`);
  const text = await res.text();
  return parseTSV(text);
}

function parseTSV(tsv){
  const lines = tsv.replace(/\r/g,"").split("\n").filter(l => l.trim() !== "");
  if (lines.length < 2) return [];
  const rawHeader = lines[0].split("\t").map(s=>s.trim());
  const header = rawHeader.map((h, i) => h !== "" ? h : `__col${i}`);

  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split("\t");
    const obj = {};
    for (let c=0;c<header.length;c++){
      obj[header[c]] = (cols[c] ?? "").trim();
    }
    rows.push(obj);
  }
  return rows;
}

/* =========================
   GAS POST
========================= */
async function postGAS(payload){
  const body = new URLSearchParams();
  body.set("payload", JSON.stringify(payload));

  const res = await fetch(GAS_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
    body
  });

  const text = await res.text();
  let json;
  try { json = JSON.parse(text); }
  catch { throw new Error("GAS応答がJSONではありません: " + text.slice(0,200)); }
  return json;
}

/* =========================
   Handoff
========================= */
function handoffToNextPage(){
  const sid = encodeURIComponent(runtime.sid || "");
  const gender = encodeURIComponent(runtime.gender || "");
  const url = `${NEXT_PAGE_URL}?sid=${sid}&gender=${gender}`;
  location.replace(url);
}

/* =========================
   MBTI helpers
========================= */
function normalizeMbtiType(type){
  const t = String(type || "").toUpperCase().replace(/[^EISNTFJP]/g,"");
  return (t.length === 4) ? t : "";
}
function inferMbtiAxesFromType(type){
  const t = normalizeMbtiType(type);
  if (!t) return {MBTI1:"",MBTI2:"",MBTI3:"",MBTI4:""};
  return {MBTI1:t[0], MBTI2:t[1], MBTI3:t[2], MBTI4:t[3]};
}
async function loadMbtiOptions(){
  const rows = await loadTSV(TSV_PATH.mbti);
  const opts = [];
  for (const r of rows){
    const label = (r["表示名"] || r["表示"] || r["Label"] || r["__col0"] || "").trim();
    if (!label) continue;

    const m = label.match(/^([EI][SN][TF][JP])/i);
    if (!m) continue;
    const type = normalizeMbtiType(m[1]);
    if (!type) continue;

    const axes = {
      MBTI1: (r.MBTI1 || "").trim(),
      MBTI2: (r.MBTI2 || "").trim(),
      MBTI3: (r.MBTI3 || "").trim(),
      MBTI4: (r.MBTI4 || "").trim(),
    };
    const inferred = inferMbtiAxesFromType(type);

    opts.push({
      label,
      type,
      MBTI1: axes.MBTI1 || inferred.MBTI1,
      MBTI2: axes.MBTI2 || inferred.MBTI2,
      MBTI3: axes.MBTI3 || inferred.MBTI3,
      MBTI4: axes.MBTI4 || inferred.MBTI4,
    });
  }

  const seen = new Set();
  const uniq = [];
  for (const o of opts){
    if (seen.has(o.type)) continue;
    seen.add(o.type);
    uniq.push(o);
  }
  return uniq;
}

/* =========================
   Auto send (idle + unload)
========================= */
function touchActivity_(){
  runtime.lastActivityAt = Date.now();
  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);

  runtime.idleTimer = setTimeout(async () => {
    try{
      if (!prevPageFullySent_()) return;

      const targets = currentPageTargets_();
      if (targets.length === 0) return;

      await sendCurrentPageBatch_({ force:true });
    }catch(_){}
  }, IDLE_SEND_MS);
}

function setupAutoSendOnUnload_(){
  const handler = () => {
    try{
      const targets = currentPageTargets_();
      if (targets.length === 0) return;

      const payload = {
        action: ACTIONS.BATCH,
        sessionId: runtime.sid,
        gender: runtime.gender,
        answeredAt: nowISO(),
        answers: targets
      };

      const body = new URLSearchParams();
      body.set("payload", JSON.stringify(payload));

      const blob = new Blob([body.toString()], {
        type: "application/x-www-form-urlencoded;charset=UTF-8"
      });

      if (navigator.sendBeacon) {
        navigator.sendBeacon(GAS_URL, blob);
        return;
      }

      fetch(GAS_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body: body.toString(),
        keepalive: true
      }).catch(()=>{});
    }catch(_){}
  };

  window.addEventListener("beforeunload", handler);
  window.addEventListener("pagehide", handler);
}

/* =========================
   Init
========================= */
async function init(){
  loadLS();
  if (!runtime.sid) runtime.sid = newSessionId();

  setupAutoSendOnUnload_();

  runtime.step = "landing";
  render();
}
init();

/* =========================
   Render router
========================= */
function render(){
  $dbgSid.textContent = runtime.sid || "";
  $dbgStep.textContent = runtime.step || "";

  if (runtime.step === "landing") return renderLanding();
  if (runtime.step === "gender") return renderGender();
  if (runtime.step === "quiz") return renderQuiz10();
  if (runtime.step === "mbti") return renderMbti();
  if (runtime.step === "handoff") return renderHandoff();
}

/* =========================
   Landing / Gender
========================= */
function renderLanding(){
  const hasProgress = !!(runtime.gender && (runtime.idx > 0 || Object.keys(runtime.answers||{}).length > 0));

  $app.innerHTML = `
    <div class="label">まずはスタート</div>
    <p class="sub">いくつかの質問に答えるだけで、あなたの傾向をスパッと整理します。</p>
    <div class="hr"></div>

    ${hasProgress ? `
      <div class="mutedBox tiny" style="margin-bottom:10px;">
        途中保存データが見つかりました。続きから再開できます。
      </div>
      <div class="row">
        <button class="btn primary" id="btnResume">続きから再開</button>
        <button class="btn danger" id="btnNewStart">最初から</button>
      </div>
    ` : `
      <button class="btn primary" id="btnStart">診断をはじめる</button>
    `}

    <p class="tiny" style="margin-top:10px;">
      ※このページ（quiz.html）は「回答送信→次ページへ引き継ぎ」まで担当します。<br/>
      ※結果の表示は次のページで行ってください。
    </p>
  `;

  if (!hasProgress){
    document.getElementById("btnStart").onclick = () => setStep("gender");
    return;
  }

  document.getElementById("btnResume").onclick = async () => {
    try{
      runtime.questions = await loadTSV(runtime.gender === "male" ? TSV_PATH.male : TSV_PATH.female);
      runtime.idx = Math.floor((runtime.idx || 0) / PAGE_SIZE) * PAGE_SIZE;
      saveLS();
      setStep("quiz");
      touchActivity_();
      // ★変更：確実にページトップへ
      setTimeout(scrollToPageTop_, 0);
    }catch(err){
      $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
        <div class="hr"></div>
        <button class="btn ghost" id="back">戻る</button>`;
      document.getElementById("back").onclick = () => setStep("landing");
    }
  };

  document.getElementById("btnNewStart").onclick = async () => {
    if (!confirm("保存データを破棄して最初からにしますか？")) return;

    // ★変更：性別維持のまま最初から
    try{
      await restartFromBeginningKeepGender_();
      if (runtime.gender){
        setStep("quiz");
        touchActivity_();
        setTimeout(scrollToPageTop_, 0);
      } else {
        // 性別が無いなら通常通り
        hardReset_();
      }
    }catch(err){
      // 例外時だけ従来動作へ
      hardReset_();
    }
  };
}

function renderGender(){
  $app.innerHTML = `
    <div class="label">質問 0 / 性別</div>
    <p class="qtitle">あなたはどれですか？</p>
    <div class="row">
      <button class="btn" id="gMale">男性</button>
      <button class="btn" id="gFemale">女性</button>
      <button class="btn" id="gOther">その他</button>
    </div>
    <p class="tiny" style="margin-top:10px;">
      ※「その他」は女性と同じ質問に進みます。<br/>
      ※それ以外の目的で性別を使用しません。
    </p>
    <div class="hr"></div>
    <button class="btn ghost" id="back">戻る</button>
  `;

  document.getElementById("gMale").onclick = () => startQuizWithGender("male");
  document.getElementById("gFemale").onclick = () => startQuizWithGender("female");
  document.getElementById("gOther").onclick = () => startQuizWithGender("female");
  document.getElementById("back").onclick = () => setStep("landing");
}

async function startQuizWithGender(gender){
  runtime.gender = gender;
  runtime.idx = 0;
  runtime.answers = {};
  runtime.questions = [];
  runtime.mbtiOptions = null;
  runtime.sentMap = {};
  runtime.inflight = false;

  runtime.sid = newSessionId();
  saveLS();

  try{
    runtime.questions = await loadTSV(gender === "male" ? TSV_PATH.male : TSV_PATH.female);
  }catch(err){
    $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">戻る</button>`;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  setStep("quiz");
  touchActivity_();
  // ★変更：ページトップへ
  setTimeout(scrollToPageTop_, 0);
}

/* =========================
   Quiz (10 questions per page)
========================= */
function renderQuiz10(){
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;

  if (!qTotal){
    $app.innerHTML = `
      <div class="err">質問データが空です。TSVの中身を確認してください。</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">性別選択に戻る</button>
    `;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  // ★変更：完了画面を挟まず、idxが末尾ならMBTIへ直行
  if (start >= qTotal){
    setStep("mbti");
    touchActivity_();
    setTimeout(scrollToPageTop_, 0);
    return;
  }

  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);

  const answeredCount = countAnswered_();
  const pct = Math.round((answeredCount / qTotal) * 100);

  const pageAnswered = slice.filter((q, i) => {
    const qid = getQid_(q, start + i);
    return !!runtime.answers[qid];
  }).length;

  // ★変更：最後のページだけ「回答完了！」にする
  const isLastPage = (end >= qTotal);
  const nextLabel = isLastPage ? "回答完了！" : "次の10問へ";

  $app.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center;">
      <span class="pill">進捗 ${answeredCount} / ${qTotal}</span>
      <span class="pill">今 ${start+1}〜${end} 問目</span>
      <span class="pill">性別: ${runtime.gender === "male" ? "男性" : "女性/その他"}</span>
    </div>

    <div class="progress" style="margin-top:10px;">
      <div class="bar" style="width:${pct}%"></div>
    </div>

    <div class="hr"></div>

    <div class="mutedBox tiny">
      このページは10問まとめて回答できます。<br/>
      送信は「${escapeHTML(nextLabel)}」または「今すぐ送信」、もしくは「10秒停止」で途中送信が走ります。<br/>
      ブラウザを閉じる場合も、未送信があれば自動送信（sendBeacon）します。
    </div>

    <div id="qList">
      ${slice.map((q, i) => renderQBlock_(q, start, i)).join("")}
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnPrevPage" ${start===0?'disabled':''}>前の10問</button>
      <button class="btn primary" id="btnNextPage" ${pageAnswered < slice.length ? 'disabled' : ''}>
        ${escapeHTML(nextLabel)}
      </button>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn good" id="btnSendNow">今すぐ送信する</button>
      <button class="btn danger" id="btnRestart">最初からやり直す</button>
    </div>

    <p class="tiny" style="margin-top:10px;">
      ※ボタンは、このページの全問が回答済みで押せます。<br/>
      ※通信が不安定でもローカル保存は残ります。
    </p>

    <div id="msg"></div>
  `;

  // 選択肢クリック
  document.querySelectorAll("[data-qid][data-opt]").forEach(btn => {
    btn.onclick = () => {
      const qid = btn.getAttribute("data-qid");
      const opt = btn.getAttribute("data-opt");
      onAnswer_(qid, opt);
    };
  });

  document.getElementById("btnPrevPage").onclick = () => {
    runtime.idx = clamp(runtime.idx - PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
    touchActivity_();
    // ★変更：ページトップへ
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnNextPage").onclick = async () => {
    if (!isPageComplete_(slice, start)) return;

    // ★送信を「待たずに」先に画面遷移（裏送信）
    const targets = currentPageTargets_(); // この瞬間の対象を確定
    sendTargetsInBackground_(targets);

    if (isLastPage){
      // ★変更：完了画面を挟まず、MBTIへ即移動
      setStep("mbti");
      touchActivity_();
      setTimeout(scrollToPageTop_, 0);
      return;
    }

    runtime.idx = clamp(runtime.idx + PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
    touchActivity_();
    // ★変更：ページトップへ
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnSendNow").onclick = async () => {
    await sendCurrentPageBatch_({ force:true, statusElId: "msg" });
    touchActivity_();
  };

  document.getElementById("btnRestart").onclick = async () => {
    if (!confirm("最初からやり直しますか？")) return;

    // ★変更：性別維持のままQ1へ
    try{
      await restartFromBeginningKeepGender_();
      setStep("quiz");
      touchActivity_();
      setTimeout(scrollToPageTop_, 0);
    }catch(_){
      // 例外時だけ従来動作
      hardReset_();
    }
  };

  // ページ表示時：アイドルタイマー稼働
  touchActivity_();
}

function renderQBlock_(q, pageStart, i){
  const idx = pageStart + i;
  const qid = getQid_(q, idx);
  const text = q["質問文"] || q["question"] || q["Question"] || q["質問"] || "";
  const answered = runtime.answers[qid] || "";

  // 選択肢は「10→1」
  const opts = [];
  for (let n=10;n>=1;n--){
    const key = `選択肢${n}`;
    if (q[key] != null && String(q[key]).trim() !== "") {
      opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
    }
  }
  if (!opts.length){
    for (let n=10;n>=1;n--){
      const key = `OPT${n}`;
      if (q[key] != null && String(q[key]).trim() !== "") {
        opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
      }
    }
  }

  return `
    <div class="qblock" id="block_${escapeHTML(qid)}">
      <div class="qhead">
        <div class="qnum">${escapeHTML(qid)}</div>
      </div>
      <div class="qtitle">${escapeHTML(text)}</div>
      <div class="qopt">
        ${opts.map(o => {
          const sel = (answered === o.opt);
          return `
            <button class="opt ${sel ? "selected":""}"
              data-qid="${escapeHTML(qid)}"
              data-opt="${escapeHTML(o.opt)}">
              ${escapeHTML(o.label)}
              ${sel ? ' <span class="pill" style="float:right;">選択中</span>' : ''}
            </button>
          `;
        }).join("")}
      </div>
    </div>
  `;
}

function getQid_(q, absoluteIdx){
  return q.QID || q.qid || `Q${absoluteIdx+1}`;
}

function countAnswered_(){
  return Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]).length;
}

function isPageComplete_(slice, pageStart){
  for (let i=0;i<slice.length;i++){
    const qid = getQid_(slice[i], pageStart + i);
    if (!runtime.answers[qid]) return false;
  }
  return true;
}

function currentPageQids_(){
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;
  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);
  return slice.map((q, i) => getQid_(q, start + i));
}

function currentPageTargets_(){
  const qids = currentPageQids_();
  return qids
    .filter(qid => !!runtime.answers[qid] && !runtime.sentMap[qid])
    .map(qid => ({ qid, opt: runtime.answers[qid] }));
}

// 「前ページ（10問）が全部送信済みか？」
function prevPageFullySent_(){
  const qTotal = runtime.questions.length || 0;
  if (!qTotal) return false;

  const prevStart = runtime.idx - PAGE_SIZE;
  if (prevStart < 0) return false;

  const prevEnd = Math.min(prevStart + PAGE_SIZE, qTotal);
  const prevSlice = runtime.questions.slice(prevStart, prevEnd);
  const prevQids = prevSlice.map((q, i) => getQid_(q, prevStart + i));

  if (prevQids.length === 0) return false;
  return prevQids.every(qid => !!runtime.sentMap[qid]);
}

/* =========================
   Answer handling
========================= */
function onAnswer_(qid, opt){
  runtime.answers[qid] = opt;
  saveLS();
  render();
  touchActivity_();
}

/* =========================
   Send batch (current page)
========================= */
async function sendCurrentPageBatch_(opts={}){
  const force = !!opts.force;
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  if (runtime.inflight){
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（送信中…）</div>`;
    return;
  }

  const qTotal = runtime.questions.length || 0;
  if (!qTotal) return;

  // force=false のときは「このページが全部回答済み」じゃないと送らない
  if (!force){
    const qids = currentPageQids_();
    for (const qid of qids){
      if (!runtime.answers[qid]){
        if (statusEl) statusEl.innerHTML = `<div class="tiny">（未回答があるので送信できません）</div>`;
        return;
      }
    }
  }

  const targets = currentPageTargets_(); // 回答済&未送信だけ
  if (targets.length === 0){
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（送信対象がありません）</div>`;
    return;
  }

  runtime.inflight = true;
  saveLS();

  if (statusEl) statusEl.innerHTML = `<div class="tiny">送信中…（${targets.length}件）</div>`;

  try{
    const payload = {
      action: ACTIONS.BATCH,
      sessionId: runtime.sid,
      gender: runtime.gender,
      answeredAt: nowISO(),
      answers: targets, // 1〜10件OK（GAS側も対応）
    };

    const r = await postGAS(payload);

    if (r && r.ok){
      const wrote = Array.isArray(r.wrote) ? r.wrote : [];
      if (wrote.length > 0){
        wrote.forEach(x => { if (x && x.qid) runtime.sentMap[x.qid] = true; });
      } else {
        targets.forEach(x => runtime.sentMap[x.qid] = true);
      }

      saveLS();
      if (statusEl) statusEl.innerHTML = `<div class="ok tiny">送信OK：${targets.length}件</div>`;
    } else {
      if (statusEl) statusEl.innerHTML = `<div class="err tiny">送信失敗（通信が落ち着いたら再度「今すぐ送信」してください）</div>`;
    }
  }catch(_){
    if (statusEl) statusEl.innerHTML = `<div class="err tiny">送信失敗（通信が不安定です。時間をおいて再送してください）</div>`;
  }finally{
    runtime.inflight = false;
    saveLS();
  }
}

// 完了画面用：未送信を最大10件だけ送る（雑にOK）
async function sendAllUnsentUpTo10_(opts={}){
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  if (runtime.inflight){
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（送信中…）</div>`;
    return;
  }

  // Q1.. を見て未送信だけ抽出
  const qids = Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]);
  const targets = qids.filter(qid => !runtime.sentMap[qid]).slice(0, PAGE_SIZE).map(qid => ({ qid, opt: runtime.answers[qid] }));

  if (targets.length === 0){
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（未送信はありません）</div>`;
    return;
  }

  runtime.inflight = true;
  saveLS();
  if (statusEl) statusEl.innerHTML = `<div class="tiny">送信中…（${targets.length}件）</div>`;

  try{
    const r = await postGAS({
      action: ACTIONS.BATCH,
      sessionId: runtime.sid,
      gender: runtime.gender,
      answeredAt: nowISO(),
      answers: targets
    });

    if (r?.ok){
      targets.forEach(x => runtime.sentMap[x.qid] = true);
      saveLS();
      if (statusEl) statusEl.innerHTML = `<div class="ok tiny">送信OK：${targets.length}件</div>`;
    } else {
      if (statusEl) statusEl.innerHTML = `<div class="err tiny">送信失敗</div>`;
    }
  }catch(_){
    if (statusEl) statusEl.innerHTML = `<div class="err tiny">送信失敗</div>`;
  }finally{
    runtime.inflight = false;
    saveLS();
  }
}

/* =========================
   ★追加：MBTI完了後に未送信を再送（最大50件＝10件×5回）
========================= */
async function resendAllUnsentAfterMbti_(opts={}){
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  // 送信中なら触らない（この関数はhandoffで呼ぶ想定）
  if (runtime.inflight) return;

  const allQids = Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]);
  const unsent = allQids.filter(qid => !runtime.sentMap[qid]);

  if (unsent.length === 0){
    if (statusEl) statusEl.innerHTML = `<div class="ok tiny">送信漏れはありません。</div>`;
    return;
  }

  if (statusEl) statusEl.innerHTML = `<div class="tiny">送信漏れを再送しています…（${unsent.length}件）</div>`;

  // 最大5回（50件）を想定。必要なら増やせるが今回は最小。
  const maxLoops = Math.ceil(Math.min(unsent.length, 50) / PAGE_SIZE);
  for (let i=0;i<maxLoops;i++){
    const chunkQids = Object.keys(runtime.answers || {})
      .filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k])
      .filter(qid => !runtime.sentMap[qid])
      .slice(0, PAGE_SIZE);

    if (chunkQids.length === 0) break;

    const targets = chunkQids.map(qid => ({ qid, opt: runtime.answers[qid] }));

    runtime.inflight = true;
    saveLS();

    try{
      const r = await postGAS({
        action: ACTIONS.BATCH,
        sessionId: runtime.sid,
        gender: runtime.gender,
        answeredAt: nowISO(),
        answers: targets
      });

      if (r?.ok){
        targets.forEach(x => runtime.sentMap[x.qid] = true);
        saveLS();
      }
    }catch(_){
      // 失敗したら次チャンクへは行くが、sentMapは残るので次回また拾える
    }finally{
      runtime.inflight = false;
      saveLS();
    }
  }

  const remaining = Object.keys(runtime.answers || {})
    .filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k])
    .filter(qid => !runtime.sentMap[qid]).length;

  if (statusEl){
    statusEl.innerHTML = remaining === 0
      ? `<div class="ok tiny">再送完了：送信漏れは解消しました。</div>`
      : `<div class="err tiny">一部送信できていない可能性があります（残り ${remaining}件）。通信が安定したら再度試行してください。</div>`;
  }
}

/* =========================
   ★追加：集計開始シグナル送信（sendBeacon優先）
========================= */
function signalStartAggregate_(){
  try{
    const payload = {
      action: ACTIONS.START_AGG,
      sessionId: runtime.sid,
      gender: runtime.gender,
      signaledAt: nowISO()
    };
    const body = new URLSearchParams();
    body.set("payload", JSON.stringify(payload));
    const blob = new Blob([body.toString()], { type: "application/x-www-form-urlencoded;charset=UTF-8" });

    if (navigator.sendBeacon) {
      navigator.sendBeacon(GAS_URL, blob);
    } else {
      fetch(GAS_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body: body.toString(),
        keepalive: true
      }).catch(()=>{});
    }
  }catch(_){}
}

function hardReset_(){
  runtime.sid = newSessionId();
  runtime.gender = "";
  runtime.questions = [];
  runtime.idx = 0;
  runtime.answers = {};
  runtime.mbtiOptions = null;
  runtime.sentMap = {};
  runtime.inflight = false;
  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);
  runtime.idleTimer = null;
  clearLSForRestart();
  render();
}

/* =========================
   MBTI view (send via logAnswer)
========================= */
function renderMbti(){
  $app.innerHTML = `
    <div class="label">MBTI（任意）</div>
    <p class="qtitle">もし分かれば、MBTIを選んでください（未選択でもOK）。</p>

    <div id="mbtiArea">
      <div class="tiny">候補を読み込み中…</div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnBackToQuiz">回答を見直す</button>
      <button class="btn good" id="btnNext">送信して次へ</button>
    </div>

    <div id="msg"></div>

    <p class="tiny" style="margin-top:10px;">
      ※プルダウン表示は「ENFP（運動家）」形式です。<br/>
      ※選択すると MBTI1〜4（E/I, S/N, T/F, J/P）も一緒に保存・送信します。
    </p>
  `;

  document.getElementById("btnBackToQuiz").onclick = () => {
    const qTotal = runtime.questions.length || 0;
    runtime.idx = Math.floor((Math.max(0, qTotal-1)) / PAGE_SIZE) * PAGE_SIZE;
    saveLS();
    setStep("quiz");
    touchActivity_();
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnNext").onclick = async () => {
    await saveMbtiAndGoHandoff();
  };

  (async () => {
    const area = document.getElementById("mbtiArea");
    try{
      if (!runtime.mbtiOptions) runtime.mbtiOptions = await loadMbtiOptions();

      if (!runtime.mbtiOptions || runtime.mbtiOptions.length === 0){
        area.innerHTML = `<div class="err">mbti_options.tsv は読めましたが、候補が0件でした。</div>
          <div class="tiny">（TSVの1列目に「ENFP（運動家）」形式が入っているか確認してください）</div>`;
        return;
      }

      const savedType = normalizeMbtiType(runtime.answers.MBTI || "");
      area.innerHTML = `
        <div class="label">MBTIタイプ</div>
        <select id="mbtiSelect" class="field">
          <option value="">選択しない（分からない）</option>
          ${runtime.mbtiOptions.map(o => `
            <option value="${escapeHTML(o.type)}" ${o.type === savedType ? "selected" : ""}>
              ${escapeHTML(o.label)}
            </option>
          `).join("")}
        </select>
        <div class="tiny" style="margin-top:10px;">
          ※表示は「ENFP（運動家）」、送信は「MBTI=ENFP / MBTI1..4=E N F P」です。
        </div>
      `;
    }catch(err){
      area.innerHTML = `<div class="err">MBTI候補の読込に失敗: ${escapeHTML(err.message)}</div>
        <div class="tiny">※一旦スキップして次へ進めます。</div>`;
    }
  })();

  touchActivity_();
}

/* =========================
   ★変更：MBTI完了後は「完了画面でステイ」→未送信再送→集計シグナル→nameへ
========================= */
async function saveMbtiAndGoHandoff(){
  const msg = document.getElementById("msg");
  msg.innerHTML = `<div class="tiny">送信準備中…</div>`;

  // 念のため「今ページ未送信」を送る（※runtime.idxは最後のページのままなので41〜50が拾える）
  await sendCurrentPageBatch_({ force:true, statusElId:"msg" });

  const sel = document.getElementById("mbtiSelect");
  const type = sel ? normalizeMbtiType(sel.value) : "";

  if (type){
    const found = (runtime.mbtiOptions || []).find(o => o.type === type);
    const axes = found ? {
      MBTI1: found.MBTI1 || "",
      MBTI2: found.MBTI2 || "",
      MBTI3: found.MBTI3 || "",
      MBTI4: found.MBTI4 || "",
    } : inferMbtiAxesFromType(type);

    runtime.answers.MBTI = type;
    runtime.answers.MBTI1 = axes.MBTI1;
    runtime.answers.MBTI2 = axes.MBTI2;
    runtime.answers.MBTI3 = axes.MBTI3;
    runtime.answers.MBTI4 = axes.MBTI4;
    saveLS();

    try{
      const r = await postGAS({
        action: ACTIONS.LOG,
        sessionId: runtime.sid,
        gender: runtime.gender,
        qid: "MBTI",
        opt: type,
        MBTI1: axes.MBTI1,
        MBTI2: axes.MBTI2,
        MBTI3: axes.MBTI3,
        MBTI4: axes.MBTI4,
        answeredAt: nowISO()
      });

      msg.innerHTML = r?.ok
        ? `<div class="ok">MBTIも送信しました。</div>`
        : `<div class="tiny">（MBTIの送信はローカル保存のみで継続）</div>`;
    }catch(_){
      msg.innerHTML = `<div class="tiny">（通信が不安定なのでMBTIはローカル保存のみ）</div>`;
    }
  }else{
    msg.innerHTML = `<div class="tiny">MBTIは未選択のまま進みます。</div>`;
  }

  // ★ここで「完了画面」へ
  setStep("handoff");
  touchActivity_();
  setTimeout(scrollToPageTop_, 0);
}

/* =========================
   Handoff (thank you + resend + signal + redirect)
========================= */
function renderHandoff(){
  // 多重遷移を防ぐ
  if (runtime.handoffTimer) clearTimeout(runtime.handoffTimer);
  runtime.handoffTimer = null;

  $app.innerHTML = `
    <div class="label">完了</div>
    <p class="qtitle">おつかれさまでした！ご回答ありがとうございました！</p>

    <div class="mutedBox tiny">
      いま結果の準備をしています。少しだけお待ちください。<br/>
      sessionId：<span class="mono">${escapeHTML(runtime.sid)}</span>
    </div>

    <div class="hr"></div>

    <div id="handoffMsg" class="tiny">送信状況を確認中…</div>

    <div class="hr"></div>

    <button class="btn primary" id="go">次へ</button>
  `;

  document.getElementById("go").onclick = () => {
    // 手動でも次へ行けるが、未送信再送・シグナル送信は裏で続く
    handoffToNextPage();
  };

  // ★一度だけ裏処理を走らせる
  if (!runtime.handoffBusy){
    runtime.handoffBusy = true;

    (async () => {
      const statusEl = document.getElementById("handoffMsg");

      try{
        // ① 未送信があれば再送（最大50件）
        await resendAllUnsentAfterMbti_({ statusElId: "handoffMsg" });

        // ② 集計開始シグナル
        signalStartAggregate_();

        // ③ 少しステイしてから遷移（UX）
        runtime.handoffTimer = setTimeout(() => {
          handoffToNextPage();
        }, 1200);
      }catch(_){
        // 失敗しても遷移はする
        if (statusEl) statusEl.innerHTML = `<div class="tiny">（通信が不安定ですが次へ進みます）</div>`;
        runtime.handoffTimer = setTimeout(() => {
          handoffToNextPage();
        }, 1200);
      }
    })();
  }
}
</script>
</body>
</html>
