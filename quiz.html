<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>大人の診断テスト</title>
  <style>
  :root{
    /* 温かい配色（クリーム×ピーチ×ココア） */
    --bg1:#fff7ef;
    --bg2:#fff1f6;

    --card:#ffffffcc;
    --text:#2b2b2b;
    --muted:#6b7280;

    --accent:#ff7a59;   /* コーラル */
    --accent2:#34d399;  /* やさしいグリーン */
    --danger:#ef4444;

    --line:#f1d7c8;

    --shadow: 0 10px 30px rgba(20,10,5,.08);
    --shadow2: 0 6px 18px rgba(20,10,5,.06);

    --radius: 18px;
    --radius2: 14px;
  }

  *{box-sizing:border-box}

  body{
    margin:0;
    font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", Roboto,
      "Hiragino Maru Gothic ProN", "Hiragino Kaku Gothic ProN", "Noto Sans JP",
      "Yu Gothic", sans-serif;
    background: radial-gradient(1200px 700px at 20% 10%, var(--bg2), transparent 60%),
                radial-gradient(1200px 700px at 80% 0%, #fffbe6, transparent 55%),
                linear-gradient(180deg, var(--bg1), #ffffff);
    color:var(--text);
  }

  a{color:inherit}

  .wrap{
    max-width:760px;
    margin:0 auto;
    padding:18px 14px 40px;
  }

.hero{
  padding:18px 16px;
  border:1px solid var(--line);
  border-radius:var(--radius);
  background:rgba(255,255,255,.78);
  box-shadow: var(--shadow);
  backdrop-filter: blur(10px);
  text-align:center;
}

  h1{
    font-size:22px;
    margin:0 0 8px;
    letter-spacing: .2px;
  }

  .sub{
    color:var(--muted);
    line-height:1.7;
    margin:0;
  }

  .card{
    margin-top:14px;
    padding:16px;
    border:1px solid var(--line);
    border-radius:var(--radius);
    background:rgba(255,255,255,.72);
    box-shadow: var(--shadow2);
  }

  .row{display:flex;gap:10px;flex-wrap:wrap}

  .btn{
    appearance:none;
    border:1px solid #f3d2c2;
    background:#ffffff;
    color:var(--text);
    padding:12px 14px;
    border-radius:var(--radius2);
    font-weight:800;
    cursor:pointer;
    flex:1;
    min-width:140px;
    box-shadow: 0 4px 12px rgba(20,10,5,.06);
    transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease;
  }

  .btn:hover{
    border-color:#f0bfa8;
    box-shadow: 0 8px 18px rgba(20,10,5,.08);
  }

  .btn:active{
    transform: translateY(1px);
  }

  .btn.primary{
    background: linear-gradient(90deg, #ff8a6b, #ff6b8a);
    border-color: transparent;
    color:#fff;
  }

  .btn.good{
    background: linear-gradient(90deg, #34d399, #22c55e);
    border-color: transparent;
    color:#0b2b1f;
  }

  .btn.ghost{
    background: transparent;
    box-shadow: none;
  }

  .btn.danger{
    background: rgba(239,68,68,.08);
    border-color: rgba(239,68,68,.28);
    color:#7f1d1d;
    box-shadow:none;
  }

  .btn:disabled{opacity:.55;cursor:not-allowed}

  .label{
    font-size:12px;
    color:var(--muted);
    margin:0 0 8px;
  }

  .progress{
    height:10px;
    background:#fff;
    border:1px solid var(--line);
    border-radius:999px;
    overflow:hidden;
    box-shadow: inset 0 1px 3px rgba(20,10,5,.05);
  }

  .bar{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, #ff8a6b, #34d399);
    transition:width .25s;
  }

  .qtitle{
    font-size:16px;
    font-weight:900;
    margin:0 0 10px;
    line-height:1.6;
  }

  .opt{
    display:block;
    width:100%;
    text-align:left;
    margin:10px 0;
    padding:12px 12px;
    border-radius:var(--radius2);
    border:1px solid #f3d2c2;
    background:#fff;
    color:var(--text);
    cursor:pointer;
    box-shadow: 0 3px 10px rgba(20,10,5,.05);
    transition: transform .06s ease, border-color .2s ease;
  }

  .opt:hover{
    border-color:#f0bfa8;
  }

  .opt:active{
    transform: translateY(1px);
  }

  .opt.selected{
    outline: 3px solid rgba(255,122,89,.28);
    border-color:#ffb19b;
  }

  .tiny{
    font-size:12px;
    color:var(--muted);
    line-height:1.7;
  }

  .field{
    width:100%;
    padding:12px;
    border-radius:var(--radius2);
    border:1px solid #f3d2c2;
    background:#fff;
    color:var(--text);
    font-size:16px;
  }

  select.field{appearance:auto;}

  .hr{
    height:1px;
    background: linear-gradient(90deg, transparent, var(--line), transparent);
    margin:14px 0;
  }

  .pill{
    display:inline-block;
    padding:6px 10px;
    border:1px solid #f3d2c2;
    border-radius:999px;
    color:#6b7280;
    font-size:12px;
    background:rgba(255,255,255,.75);
  }

  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  .err{
    color:#7f1d1d;
    background: rgba(239,68,68,.08);
    border:1px solid rgba(239,68,68,.25);
    padding:10px;
    border-radius:var(--radius2);
    margin-top:10px;
  }

  .ok{
    color:#064e3b;
    background: rgba(34,197,94,.10);
    border:1px solid rgba(34,197,94,.25);
    padding:10px;
    border-radius:var(--radius2);
    margin-top:10px;
  }

  .mutedBox{
    border:1px dashed #f0c7b1;
    border-radius:var(--radius2);
    padding:10px;
    color:var(--muted);
    line-height:1.8;
    background: rgba(255,255,255,.55);
  }

  /* 10問表示 */
  .qblock{
    border:1px solid #f3d2c2;
    border-radius:var(--radius);
    padding:12px;
    margin:12px 0;
    background: rgba(255,255,255,.75);
    box-shadow: 0 6px 18px rgba(20,10,5,.05);
  }

  .qhead{
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:space-between;
    margin-bottom:8px;
    flex-wrap:wrap;
  }

  .qnum{font-weight:900}
  .qopt{margin:8px 0}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>あなたの特性が驚くほどわかる！<br/>大人の診断テスト！</h1>
      <p class="sub">
        無料招待URLへようこそ！<br/>
        5分以内で回答できる50問で、診断してみましょう！<br/>
        ※結果も無料のまま確認できます。
      </p>
    </div>

    <div id="app" class="card"></div>


  </div>

<script>
/* =========================
   Config
========================= */
const GAS_URL = "https://script.google.com/macros/s/AKfycbz0nSbcIZKV6P3d8NPu1mZKRjVLT2EF6grR5nfc2otxiky6jdaRBiFhskvjoemWUlOn/exec";
const NEXT_PAGE_URL = "name.html";

// GAS actions
const ACTIONS = {
  LOG: "logAnswer",
  BATCH: "logAnswersBatch",
  // ★追加（集計開始シグナル）
  START_AGG: "startAggregate",
};

const TSV_PATH = {
  male: "data/male_questions.tsv",
  female: "data/female_questions.tsv",
  mbti: "data/mbti_options.tsv"
};

// 10問ずつ
const PAGE_SIZE = 10;

// 10秒停止で途中送信
const IDLE_SEND_MS = 10_000;

const LS = {
  gender: "diag_gender",
  sid: "diag_sid",
  answers: "diag_answers",
  progress: "diag_progress",
  sent: "diag_sent",          // 送信済みqid一覧
};

let runtime = {
  step: "landing",
  sid: "",
  gender: "",
  questions: [],
  // idx: 0,10,20...
  idx: 0,
  answers: {},
  mbtiOptions: null,

  // 送信済み判定（qid -> true）
  sentMap: {},

  // 送信中ロック
  inflight: false,

  // ★追加：裏送信用ロック（UIは止めない）
  bgInflight: false,

  // アイドルタイマー
  idleTimer: null,
  lastActivityAt: 0,

  // ★追加：handoff多重遷移防止
  handoffTimer: null,
  handoffBusy: false,
};

const $app = document.getElementById("app");
const $dbgSid = document.getElementById("dbgSid");
const $dbgStep = document.getElementById("dbgStep");

/* =========================
   Utils
========================= */
function setStep(step){ runtime.step = step; render(); }
function escapeHTML(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function nowISO(){ return new Date().toISOString(); }
function newSessionId(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "sid_" + Date.now() + "_" + Math.random().toString(16).slice(2);
}
function optStr(n){ return "OPT" + String(n); }
function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

/* =========================
   ★改良：確実に「ページ最上部」へスクロール
   - iOS含め効くように scrollTop を複数経路で0に
========================= */
function scrollToPageTop_(){
  try{
    // 即時
    window.scrollTo(0, 0);
    if (document.documentElement) document.documentElement.scrollTop = 0;
    if (document.body) document.body.scrollTop = 0;

    // DOM反映後にも叩く（レンダー直後に効かない端末対策）
    requestAnimationFrame(() => {
      window.scrollTo(0, 0);
      if (document.documentElement) document.documentElement.scrollTop = 0;
      if (document.body) document.body.scrollTop = 0;
      requestAnimationFrame(() => {
        window.scrollTo(0, 0);
        if (document.documentElement) document.documentElement.scrollTop = 0;
        if (document.body) document.body.scrollTop = 0;
      });
    });
  }catch(_){}
}

/* =========================
   ★改良：ページ遷移後に「裏で送信」する（UIを止めない）
   - targets を事前に確定して送るので idx が変わってもOK
========================= */
function sendTargetsInBackground_(targets){
  try{
    if (!targets || targets.length === 0) return;
    if (runtime.bgInflight) return; // 多重発火を抑止（最低限）
    runtime.bgInflight = true;

    (async () => {
      try{
        const payload = {
          action: ACTIONS.BATCH,
          sessionId: runtime.sid,
          gender: runtime.gender,
          answeredAt: nowISO(),
          answers: targets
        };
        const r = await postGAS(payload);
        if (r && r.ok){
          targets.forEach(x => { if (x && x.qid) runtime.sentMap[x.qid] = true; });
          saveLS();
        }
      }catch(_){
        // 失敗しても「未送信」のまま残るので、次の送信チャンスで回収できる
      }finally{
        runtime.bgInflight = false;
      }
    })();
  }catch(_){}
}

/* =========================
   ★改良：「最初からやり直す」でも性別は維持
   - gender は残す
   - questions も維持（空なら gender から再読込）
========================= */
async function restartFromBeginningKeepGender_(){
  const g = runtime.gender || localStorage.getItem(LS.gender) || "";
  runtime.gender = g;

  runtime.sid = newSessionId();
  runtime.idx = 0;
  runtime.answers = {};
  runtime.sentMap = {};
  runtime.inflight = false;

  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);
  runtime.idleTimer = null;

  // answers/progress/sent は消す（genderは消さない）
  localStorage.removeItem(LS.answers);
  localStorage.removeItem(LS.progress);
  localStorage.removeItem(LS.sent);
  localStorage.setItem(LS.gender, runtime.gender);

  // questions が無ければ gender から再読込（TSVありません問題の回避）
  if (!runtime.questions || runtime.questions.length === 0){
    if (runtime.gender){
      runtime.questions = await loadTSV(runtime.gender === "male" ? TSV_PATH.male : TSV_PATH.female);
    }
  }

  saveLS();
}

/* =========================
   LocalStorage
========================= */
function loadLS(){
  const sid = localStorage.getItem(LS.sid);
  const gender = localStorage.getItem(LS.gender);
  const answersRaw = localStorage.getItem(LS.answers);
  const progressRaw = localStorage.getItem(LS.progress);
  const sentRaw = localStorage.getItem(LS.sent);

  if (sid) runtime.sid = sid;
  if (gender) runtime.gender = gender;

  if (answersRaw){
    try{ runtime.answers = JSON.parse(answersRaw) || {}; }catch(_){}
  }
  if (progressRaw){
    try{
      const p = JSON.parse(progressRaw) || {};
      runtime.idx = Number(p.idx || 0);
    }catch(_){}
  }
  if (sentRaw){
    try{ runtime.sentMap = JSON.parse(sentRaw) || {}; }catch(_){}
  }
}

function saveLS(){
  localStorage.setItem(LS.sid, runtime.sid);
  localStorage.setItem(LS.gender, runtime.gender);
  localStorage.setItem(LS.answers, JSON.stringify(runtime.answers || {}));
  localStorage.setItem(LS.progress, JSON.stringify({ idx: runtime.idx, savedAt: nowISO() }));
  localStorage.setItem(LS.sent, JSON.stringify(runtime.sentMap || {}));
}

function clearLSForRestart(){
  localStorage.removeItem(LS.gender);
  localStorage.removeItem(LS.sid);
  localStorage.removeItem(LS.answers);
  localStorage.removeItem(LS.progress);
  localStorage.removeItem(LS.sent);
}

/* =========================
   TSV
========================= */
async function loadTSV(path){
  const res = await fetch(path, { cache:"no-store" });
  if (!res.ok) throw new Error(`TSV読込に失敗: ${path}`);
  const text = await res.text();
  return parseTSV(text);
}

function parseTSV(tsv){
  const lines = tsv.replace(/\r/g,"").split("\n").filter(l => l.trim() !== "");
  if (lines.length < 2) return [];
  const rawHeader = lines[0].split("\t").map(s=>s.trim());
  const header = rawHeader.map((h, i) => h !== "" ? h : `__col${i}`);

  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split("\t");
    const obj = {};
    for (let c=0;c<header.length;c++){
      obj[header[c]] = (cols[c] ?? "").trim();
    }
    rows.push(obj);
  }
  return rows;
}

/* =========================
   GAS POST
========================= */
async function postGAS(payload){
  const body = new URLSearchParams();
  body.set("payload", JSON.stringify(payload));

  const maxTry = 5;
  for (let t=1; t<=maxTry; t++){
    try{
      const res = await fetch(GAS_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body
      });

      const text = await res.text();
      let json;
      try { json = JSON.parse(text); }
      catch { throw new Error("GAS応答がJSONではありません: " + text.slice(0,200)); }

      // ★busyなら待ってリトライ
      if (json && json.ok === false && json.error === "busy"){
        const wait = Number(json.retryAfterMs || 800);
        await new Promise(r => setTimeout(r, wait + Math.floor(Math.random()*200)));
        continue;
      }

      return json;

    }catch(err){
      // 通信エラーもリトライ（指数バックオフ）
      if (t === maxTry) throw err;
      const backoff = Math.min(2000, 300 * (2 ** (t-1)));
      await new Promise(r => setTimeout(r, backoff + Math.floor(Math.random()*200)));
    }
  }
}


/* =========================
   Handoff
========================= */
function handoffToNextPage(){
  const sid = encodeURIComponent(runtime.sid || "");
  const gender = encodeURIComponent(runtime.gender || "");
  const url = `${NEXT_PAGE_URL}?sid=${sid}&gender=${gender}`;
  location.replace(url);
}

/* =========================
   MBTI helpers
========================= */
function normalizeMbtiType(type){
  const t = String(type || "").toUpperCase().replace(/[^EISNTFJP]/g,"");
  return (t.length === 4) ? t : "";
}
function inferMbtiAxesFromType(type){
  const t = normalizeMbtiType(type);
  if (!t) return {MBTI1:"",MBTI2:"",MBTI3:"",MBTI4:""};
  return {MBTI1:t[0], MBTI2:t[1], MBTI3:t[2], MBTI4:t[3]};
}
async function loadMbtiOptions(){
  const rows = await loadTSV(TSV_PATH.mbti);
  const opts = [];
  for (const r of rows){
    const label = (r["表示名"] || r["表示"] || r["Label"] || r["__col0"] || "").trim();
    if (!label) continue;

    const m = label.match(/^([EI][SN][TF][JP])/i);
    if (!m) continue;
    const type = normalizeMbtiType(m[1]);
    if (!type) continue;

    const axes = {
      MBTI1: (r.MBTI1 || "").trim(),
      MBTI2: (r.MBTI2 || "").trim(),
      MBTI3: (r.MBTI3 || "").trim(),
      MBTI4: (r.MBTI4 || "").trim(),
    };
    const inferred = inferMbtiAxesFromType(type);

    opts.push({
      label,
      type,
      MBTI1: axes.MBTI1 || inferred.MBTI1,
      MBTI2: axes.MBTI2 || inferred.MBTI2,
      MBTI3: axes.MBTI3 || inferred.MBTI3,
      MBTI4: axes.MBTI4 || inferred.MBTI4,
    });
  }

  const seen = new Set();
  const uniq = [];
  for (const o of opts){
    if (seen.has(o.type)) continue;
    seen.add(o.type);
    uniq.push(o);
  }
  return uniq;
}

/* =========================
   Auto send (idle + unload)
========================= */
function touchActivity_(){
  runtime.lastActivityAt = Date.now();
  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);

  runtime.idleTimer = setTimeout(async () => {
    try{
      if (!prevPageFullySent_()) return;

      const targets = currentPageTargets_();
      if (targets.length === 0) return;

      await sendCurrentPageBatch_({ force:true });
    }catch(_){}
  }, IDLE_SEND_MS);
}

function setupAutoSendOnUnload_(){
  const handler = () => {
    try{
      const targets = currentPageTargets_();
      if (targets.length === 0) return;

      const payload = {
        action: ACTIONS.BATCH,
        sessionId: runtime.sid,
        gender: runtime.gender,
        answeredAt: nowISO(),
        answers: targets
      };

      const body = new URLSearchParams();
      body.set("payload", JSON.stringify(payload));

      const blob = new Blob([body.toString()], {
        type: "application/x-www-form-urlencoded;charset=UTF-8"
      });

      if (navigator.sendBeacon) {
        navigator.sendBeacon(GAS_URL, blob);
        return;
      }

      fetch(GAS_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body: body.toString(),
        keepalive: true
      }).catch(()=>{});
    }catch(_){}
  };

  window.addEventListener("beforeunload", handler);
  window.addEventListener("pagehide", handler);
}

/* =========================
   Init
========================= */
async function init(){
  loadLS();
  if (!runtime.sid) runtime.sid = newSessionId();

  setupAutoSendOnUnload_();

  runtime.step = "landing";
  render();
}
init();

/* =========================
   Render router
========================= */
function render(){
  if ($dbgSid) $dbgSid.textContent = runtime.sid || "";
  if ($dbgStep) $dbgStep.textContent = runtime.step || "";


  if (runtime.step === "landing") return renderLanding();
  if (runtime.step === "gender") return renderGender();
  if (runtime.step === "quiz") return renderQuiz10();
  if (runtime.step === "mbti") return renderMbti();
  if (runtime.step === "handoff") return renderHandoff();
}

/* =========================
   Landing / Gender
========================= */
function renderLanding(){
  const hasProgress = !!(runtime.gender && (runtime.idx > 0 || Object.keys(runtime.answers||{}).length > 0));

  $app.innerHTML = `
    ${hasProgress ? `
      <div class="mutedBox tiny" style="margin-bottom:10px;">
        途中保存データが見つかりました。続きから再開できます。
      </div>
      <div class="row" style="justify-content:center;">
        <button class="btn primary" id="btnResume" style="flex:0; min-width:180px;">続きから再開</button>
        <button class="btn danger" id="btnNewStart" style="flex:0; min-width:140px;">最初から</button>
      </div>
    ` : `
      <div class="row" style="justify-content:center;">
        <button class="btn primary" id="btnStart" style="flex:0; width:240px;">診断をはじめる</button>
      </div>
    `}
  `;


  if (!hasProgress){
    document.getElementById("btnStart").onclick = () => setStep("gender");
    return;
  }

  document.getElementById("btnResume").onclick = async () => {
    try{
      runtime.questions = await loadTSV(runtime.gender === "male" ? TSV_PATH.male : TSV_PATH.female);
      runtime.idx = Math.floor((runtime.idx || 0) / PAGE_SIZE) * PAGE_SIZE;
      saveLS();
      setStep("quiz");
      touchActivity_();
      // ★変更：確実にページトップへ
      setTimeout(scrollToPageTop_, 0);
    }catch(err){
      $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
        <div class="hr"></div>
        <button class="btn ghost" id="back">戻る</button>`;
      document.getElementById("back").onclick = () => setStep("landing");
    }
  };

  document.getElementById("btnNewStart").onclick = async () => {
    if (!confirm("保存データを破棄して最初からにしますか？")) return;

    // ★変更：性別維持のまま最初から
    try{
      await restartFromBeginningKeepGender_();
      if (runtime.gender){
        setStep("quiz");
        touchActivity_();
        setTimeout(scrollToPageTop_, 0);
      } else {
        // 性別が無いなら通常通り
        hardReset_();
      }
    }catch(err){
      // 例外時だけ従来動作へ
      hardReset_();
    }
  };
}

function renderGender(){
  $app.innerHTML = `
    <div class="label">質問 0 / 性別</div>
    <p class="qtitle">あなたの性別は？</p>
    <div class="row">
      <button class="btn" id="gMale">男性</button>
      <button class="btn" id="gFemale">女性</button>
      <button class="btn" id="gOther">その他</button>
    </div>
    <p class="tiny" style="margin-top:10px;">
      ※質問項目の調整、内部点数の調整以外で性別を使用しません。
    </p>
  `;

  document.getElementById("gMale").onclick = () => startQuizWithGender("male");
  document.getElementById("gFemale").onclick = () => startQuizWithGender("female");
  document.getElementById("gOther").onclick = () => startQuizWithGender("female");
}


async function startQuizWithGender(gender){
  runtime.gender = gender;
  runtime.idx = 0;
  runtime.answers = {};
  runtime.questions = [];
  runtime.mbtiOptions = null;
  runtime.sentMap = {};
  runtime.inflight = false;

  runtime.sid = newSessionId();
  saveLS();

  try{
    runtime.questions = await loadTSV(gender === "male" ? TSV_PATH.male : TSV_PATH.female);
  }catch(err){
    $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">戻る</button>`;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  setStep("quiz");
  touchActivity_();
  // ★変更：ページトップへ
  setTimeout(scrollToPageTop_, 0);
}

/* =========================
   Quiz (10 questions per page)
========================= */
function renderQuiz10(){
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;

  if (!qTotal){
    $app.innerHTML = `
      <div class="err">質問データが空です。TSVの中身を確認してください。</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">性別選択に戻る</button>
    `;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  // ★変更：完了画面を挟まず、idxが末尾ならMBTIへ直行
  if (start >= qTotal){
    setStep("mbti");
    touchActivity_();
    setTimeout(scrollToPageTop_, 0);
    return;
  }

  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);

  const answeredCount = countAnswered_();
  const pct = Math.round((answeredCount / qTotal) * 100);

  const pageAnswered = slice.filter((q, i) => {
    const qid = getQid_(q, start + i);
    return !!runtime.answers[qid];
  }).length;

  // ★変更：最後のページだけ「回答完了！」にする
  const isLastPage = (end >= qTotal);
  const nextLabel = isLastPage ? "回答完了！" : "次の10問へ";

  $app.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center;">
      <span class="pill">進捗 ${answeredCount} / ${qTotal}</span>
      <span class="pill">今 ${start+1}〜${end} 問目</span>
    </div>

    <div class="progress" style="margin-top:10px;">
      <div class="bar" style="width:${pct}%"></div>
    </div>

    <div class="hr"></div>


    <div id="qList">
      ${slice.map((q, i) => renderQBlock_(q, start, i)).join("")}
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnPrevPage" ${start===0?'disabled':''}>前の10問</button>
      <button class="btn primary" id="btnNextPage" ${pageAnswered < slice.length ? 'disabled' : ''}>
        ${escapeHTML(nextLabel)}
      </button>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn danger" id="btnRestart">最初からやり直す</button>
    </div>

    <div id="msg"></div>
  `;

  // 選択肢クリック
  document.querySelectorAll("[data-qid][data-opt]").forEach(btn => {
    btn.onclick = () => {
      const qid = btn.getAttribute("data-qid");
      const opt = btn.getAttribute("data-opt");
      onAnswer_(qid, opt);
    };
  });

  document.getElementById("btnPrevPage").onclick = () => {
    runtime.idx = clamp(runtime.idx - PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
    touchActivity_();
    // ★変更：ページトップへ
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnNextPage").onclick = async () => {
    if (!isPageComplete_(slice, start)) return;

    // ★送信を「待たずに」先に画面遷移（裏送信）
    const targets = currentPageTargets_(); // この瞬間の対象を確定
    sendTargetsInBackground_(targets);

    if (isLastPage){
      // ★変更：完了画面を挟まず、MBTIへ即移動
      setStep("mbti");
      touchActivity_();
      setTimeout(scrollToPageTop_, 0);
      return;
    }

    runtime.idx = clamp(runtime.idx + PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
    touchActivity_();
    // ★変更：ページトップへ
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnRestart").onclick = async () => {
    if (!confirm("最初からやり直しますか？")) return;

    // ★変更：性別維持のままQ1へ
    try{
      await restartFromBeginningKeepGender_();
      setStep("quiz");
      touchActivity_();
      setTimeout(scrollToPageTop_, 0);
    }catch(_){
      // 例外時だけ従来動作
      hardReset_();
    }
  };

  // ページ表示時：アイドルタイマー稼働
  touchActivity_();
}

function renderQBlock_(q, pageStart, i){
  const idx = pageStart + i;
  const qid = getQid_(q, idx);
  const text = q["質問文"] || q["question"] || q["Question"] || q["質問"] || "";
  const answered = runtime.answers[qid] || "";

  // 選択肢は「10→1」
  const opts = [];
  for (let n=10;n>=1;n--){
    const key = `選択肢${n}`;
    if (q[key] != null && String(q[key]).trim() !== "") {
      opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
    }
  }
  if (!opts.length){
    for (let n=10;n>=1;n--){
      const key = `OPT${n}`;
      if (q[key] != null && String(q[key]).trim() !== "") {
        opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
      }
    }
  }

  return `
    <div class="qblock" id="block_${escapeHTML(qid)}">
      <div class="qhead">
        <div class="qnum">${escapeHTML(qid)}</div>
      </div>
      <div class="qtitle">${escapeHTML(text)}</div>
      <div class="qopt">
        ${opts.map(o => {
          const sel = (answered === o.opt);
          return `
            <button class="opt ${sel ? "selected":""}"
              data-qid="${escapeHTML(qid)}"
              data-opt="${escapeHTML(o.opt)}">
              ${escapeHTML(o.label)}
              ${sel ? ' <span class="pill" style="float:right;">選択中</span>' : ''}
            </button>
          `;
        }).join("")}
      </div>
    </div>
  `;
}

function getQid_(q, absoluteIdx){
  return q.QID || q.qid || `Q${absoluteIdx+1}`;
}

function countAnswered_(){
  return Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]).length;
}

function isPageComplete_(slice, pageStart){
  for (let i=0;i<slice.length;i++){
    const qid = getQid_(slice[i], pageStart + i);
    if (!runtime.answers[qid]) return false;
  }
  return true;
}

function currentPageQids_(){
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;
  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);
  return slice.map((q, i) => getQid_(q, start + i));
}

function currentPageTargets_(){
  const qids = currentPageQids_();
  return qids
    .filter(qid => !!runtime.answers[qid] && !runtime.sentMap[qid])
    .map(qid => ({ qid, opt: runtime.answers[qid] }));
}

// 「前ページ（10問）が全部送信済みか？」
function prevPageFullySent_(){
  const qTotal = runtime.questions.length || 0;
  if (!qTotal) return false;

  const prevStart = runtime.idx - PAGE_SIZE;
  if (prevStart < 0) return false;

  const prevEnd = Math.min(prevStart + PAGE_SIZE, qTotal);
  const prevSlice = runtime.questions.slice(prevStart, prevEnd);
  const prevQids = prevSlice.map((q, i) => getQid_(q, prevStart + i));

  if (prevQids.length === 0) return false;
  return prevQids.every(qid => !!runtime.sentMap[qid]);
}

/* =========================
   Answer handling
========================= */
function onAnswer_(qid, opt){
  runtime.answers[qid] = opt;
  saveLS();
  render();
  touchActivity_();
}

/* =========================
   Send batch (current page)
========================= */
async function sendCurrentPageBatch_(opts={}){
  const force = !!opts.force;
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  if (runtime.inflight){
    if (statusEl) statusEl.innerHTML = ``;
    return;
  }

  const qTotal = runtime.questions.length || 0;
  if (!qTotal) return;

  // force=false のときは「このページが全部回答済み」じゃないと送らない
  if (!force){
    const qids = currentPageQids_();
    for (const qid of qids){
      if (!runtime.answers[qid]){
        if (statusEl) statusEl.innerHTML = ``;
        return;
      }
    }
  }

  const targets = currentPageTargets_(); // 回答済&未送信だけ
  if (targets.length === 0){
    if (statusEl) statusEl.innerHTML = ``;
    return;
  }

  runtime.inflight = true;
  saveLS();

  if (statusEl) statusEl.innerHTML = ``;

  try{
    const payload = {
      action: ACTIONS.BATCH,
      sessionId: runtime.sid,
      gender: runtime.gender,
      answeredAt: nowISO(),
      answers: targets, // 1〜10件OK（GAS側も対応）
    };

    const r = await postGAS(payload);

    if (r && r.ok){
      const wrote = Array.isArray(r.wrote) ? r.wrote : [];
      if (wrote.length > 0){
        wrote.forEach(x => { if (x && x.qid) runtime.sentMap[x.qid] = true; });
      } else {
        targets.forEach(x => runtime.sentMap[x.qid] = true);
      }

      saveLS();
      if (statusEl) statusEl.innerHTML = ``;
    } else {
      if (statusEl) statusEl.innerHTML = ``;
    }
  }catch(_){
    if (statusEl) statusEl.innerHTML = ``;
  }finally{
    runtime.inflight = false;
    saveLS();
  }
}

// 完了画面用：未送信を最大10件だけ送る（雑にOK）
async function sendAllUnsentUpTo10_(opts={}){
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  if (runtime.inflight){
    if (statusEl) statusEl.innerHTML = ``;
    return;
  }

  // Q1.. を見て未送信だけ抽出
  const qids = Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]);
  const targets = qids.filter(qid => !runtime.sentMap[qid]).slice(0, PAGE_SIZE).map(qid => ({ qid, opt: runtime.answers[qid] }));

  if (targets.length === 0){
    if (statusEl) statusEl.innerHTML = ``;
    return;
  }

  runtime.inflight = true;
  saveLS();
  if (statusEl) statusEl.innerHTML = ``;

  try{
    const r = await postGAS({
      action: ACTIONS.BATCH,
      sessionId: runtime.sid,
      gender: runtime.gender,
      answeredAt: nowISO(),
      answers: targets
    });

    if (r?.ok){
      targets.forEach(x => runtime.sentMap[x.qid] = true);
      saveLS();
      if (statusEl) statusEl.innerHTML = ``;
    } else {
      if (statusEl) statusEl.innerHTML = ``;
    }
  }catch(_){
    if (statusEl) statusEl.innerHTML = ``;
  }finally{
    runtime.inflight = false;
    saveLS();
  }
}

/* =========================
   ★追加：MBTI完了後に未送信を再送（最大50件＝10件×5回）
========================= */
async function resendAllUnsentAfterMbti_(opts={}){
  const statusElId = opts.statusElId || null;
  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  // 送信中なら触らない（この関数はhandoffで呼ぶ想定）
  if (runtime.inflight) return;

  const allQids = Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k]);
  const unsent = allQids.filter(qid => !runtime.sentMap[qid]);

  if (unsent.length === 0){
    if (statusEl) statusEl.innerHTML = ``;
    return;
  }

  if (statusEl) statusEl.innerHTML = ``;

  // 最大5回（50件）を想定。必要なら増やせるが今回は最小。
  const maxLoops = Math.ceil(Math.min(unsent.length, 50) / PAGE_SIZE);
  for (let i=0;i<maxLoops;i++){
    const chunkQids = Object.keys(runtime.answers || {})
      .filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k])
      .filter(qid => !runtime.sentMap[qid])
      .slice(0, PAGE_SIZE);

    if (chunkQids.length === 0) break;

    const targets = chunkQids.map(qid => ({ qid, opt: runtime.answers[qid] }));

    runtime.inflight = true;
    saveLS();

    try{
      const r = await postGAS({
        action: ACTIONS.BATCH,
        sessionId: runtime.sid,
        gender: runtime.gender,
        answeredAt: nowISO(),
        answers: targets
      });

      if (r?.ok){
        targets.forEach(x => runtime.sentMap[x.qid] = true);
        saveLS();
      }
    }catch(_){
      // 失敗したら次チャンクへは行くが、sentMapは残るので次回また拾える
    }finally{
      runtime.inflight = false;
      saveLS();
    }
  }

  const remaining = Object.keys(runtime.answers || {})
    .filter(k => /^Q\d+$/.test(k) && !!runtime.answers[k])
    .filter(qid => !runtime.sentMap[qid]).length;

  if (statusEl){
    statusEl.innerHTML = remaining === 0
      ? `<div class="ok tiny">再送完了：送信漏れは解消しました。</div>`
      : `<div class="err tiny">一部送信できていない可能性があります（残り ${remaining}件）。通信が安定したら再度試行してください。</div>`;
  }
}

/* =========================
   ★追加：集計開始シグナル送信（sendBeacon優先）
========================= */
function signalStartAggregate_(){
  try{
    const payload = {
      action: ACTIONS.START_AGG,
      sessionId: runtime.sid,
      gender: runtime.gender,
      signaledAt: nowISO()
    };
    const body = new URLSearchParams();
    body.set("payload", JSON.stringify(payload));
    const blob = new Blob([body.toString()], { type: "application/x-www-form-urlencoded;charset=UTF-8" });

    if (navigator.sendBeacon) {
      navigator.sendBeacon(GAS_URL, blob);
    } else {
      fetch(GAS_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body: body.toString(),
        keepalive: true
      }).catch(()=>{});
    }
  }catch(_){}
}

function hardReset_(){
  runtime.sid = newSessionId();
  runtime.gender = "";
  runtime.questions = [];
  runtime.idx = 0;
  runtime.answers = {};
  runtime.mbtiOptions = null;
  runtime.sentMap = {};
  runtime.inflight = false;
  if (runtime.idleTimer) clearTimeout(runtime.idleTimer);
  runtime.idleTimer = null;
  clearLSForRestart();
  render();
}

/* =========================
   MBTI view (send via logAnswer)
========================= */
function renderMbti(){
  $app.innerHTML = `
    <div class="label">MBTI（任意）</div>
    <p class="qtitle">もし分かれば、MBTIを選んでください（未選択でもOK）。</p>

    <div id="mbtiArea">
      <div class="tiny">候補を読み込み中…</div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnBackToQuiz">回答を見直す</button>
      <button class="btn good" id="btnNext">送信して次へ</button>
    </div>

    <div id="msg"></div>

    <p class="tiny" style="margin-top:10px;">
      ※プルダウン表示は「ENFP（運動家）」形式です。<br/>
      ※選択すると MBTI1〜4（E/I, S/N, T/F, J/P）も一緒に保存・送信します。
    </p>
  `;

  document.getElementById("btnBackToQuiz").onclick = () => {
    const qTotal = runtime.questions.length || 0;
    runtime.idx = Math.floor((Math.max(0, qTotal-1)) / PAGE_SIZE) * PAGE_SIZE;
    saveLS();
    setStep("quiz");
    touchActivity_();
    setTimeout(scrollToPageTop_, 0);
  };

  document.getElementById("btnNext").onclick = async () => {
    await saveMbtiAndGoHandoff();
  };

  (async () => {
    const area = document.getElementById("mbtiArea");
    try{
      if (!runtime.mbtiOptions) runtime.mbtiOptions = await loadMbtiOptions();

      if (!runtime.mbtiOptions || runtime.mbtiOptions.length === 0){
        area.innerHTML = `<div class="err">mbti_options.tsv は読めましたが、候補が0件でした。</div>
          <div class="tiny">（TSVの1列目に「ENFP（運動家）」形式が入っているか確認してください）</div>`;
        return;
      }

      const savedType = normalizeMbtiType(runtime.answers.MBTI || "");
      area.innerHTML = `
        <div class="label">MBTIタイプ</div>
        <select id="mbtiSelect" class="field">
          <option value="">選択しない（分からない）</option>
          ${runtime.mbtiOptions.map(o => `
            <option value="${escapeHTML(o.type)}" ${o.type === savedType ? "selected" : ""}>
              ${escapeHTML(o.label)}
            </option>
          `).join("")}
        </select>
        <div class="tiny" style="margin-top:10px;">
          ※表示は「ENFP（運動家）」、送信は「MBTI=ENFP / MBTI1..4=E N F P」です。
        </div>
      `;
    }catch(err){
      area.innerHTML = `<div class="err">MBTI候補の読込に失敗: ${escapeHTML(err.message)}</div>
        <div class="tiny">※一旦スキップして次へ進めます。</div>`;
    }
  })();

  touchActivity_();
}

/* =========================
   ★変更：MBTI完了後は「完了画面でステイ」→未送信再送→集計シグナル→nameへ
========================= */
async function saveMbtiAndGoHandoff(){
  const msg = document.getElementById("msg");
  msg.innerHTML = `<div class="tiny">処理中…</div>`;

  // 念のため「今ページ未送信」を送る（※runtime.idxは最後のページのままなので41〜50が拾える）
  await sendCurrentPageBatch_({ force:true, statusElId:"msg" });

  const sel = document.getElementById("mbtiSelect");
  const type = sel ? normalizeMbtiType(sel.value) : "";

  if (type){
    const found = (runtime.mbtiOptions || []).find(o => o.type === type);
    const axes = found ? {
      MBTI1: found.MBTI1 || "",
      MBTI2: found.MBTI2 || "",
      MBTI3: found.MBTI3 || "",
      MBTI4: found.MBTI4 || "",
    } : inferMbtiAxesFromType(type);

    runtime.answers.MBTI = type;
    runtime.answers.MBTI1 = axes.MBTI1;
    runtime.answers.MBTI2 = axes.MBTI2;
    runtime.answers.MBTI3 = axes.MBTI3;
    runtime.answers.MBTI4 = axes.MBTI4;
    saveLS();

    try{
      const r = await postGAS({
        action: ACTIONS.LOG,
        sessionId: runtime.sid,
        gender: runtime.gender,
        qid: "MBTI",
        opt: type,
        MBTI1: axes.MBTI1,
        MBTI2: axes.MBTI2,
        MBTI3: axes.MBTI3,
        MBTI4: axes.MBTI4,
        answeredAt: nowISO()
      });

      msg.innerHTML = r?.ok
        ? `<div class="ok">OK！</div>`
        : `<div class="tiny">（通信が不安定な場合はローカル保存で継続します）</div>`;
    }catch(_){
      msg.innerHTML = `<div class="tiny">（通信が不安定な場合はローカル保存で継続します）</div>`;
    }
  }else{
    msg.innerHTML = `<div class="tiny">MBTIは未選択のまま進みます。</div>`;
  }

  // ★ここで「完了画面」へ
  setStep("handoff");
  touchActivity_();
  setTimeout(scrollToPageTop_, 0);
}

/* =========================
   Handoff (thank you + resend + signal + redirect)
========================= */
function renderHandoff(){
  // 多重遷移を防ぐ
  if (runtime.handoffTimer) clearTimeout(runtime.handoffTimer);
  runtime.handoffTimer = null;

  $app.innerHTML = `
    <div class="label">完了</div>
    <p class="qtitle">おつかれさまでした！ご回答ありがとうございました！</p>

    <div class="mutedBox tiny">
      いま結果の準備をしています。少しだけお待ちください。<br/>
      sessionId：<span class="mono">${escapeHTML(runtime.sid)}</span>
    </div>

    <div class="hr"></div>

    <div id="handoffMsg" class="tiny">準備中…</div>

    <div class="hr"></div>

    <button class="btn primary" id="go">次へ</button>
  `;

  document.getElementById("go").onclick = () => {
    // 手動でも次へ行けるが、未送信再送・シグナル送信は裏で続く
    handoffToNextPage();
  };

  // ★一度だけ裏処理を走らせる
  if (!runtime.handoffBusy){
    runtime.handoffBusy = true;

    (async () => {
      const statusEl = document.getElementById("handoffMsg");

      try{
        // ① 未送信があれば再送（最大50件）
        await resendAllUnsentAfterMbti_({ statusElId: "handoffMsg" });

        // ② 集計開始シグナル
        signalStartAggregate_();

        // ③ 少しステイしてから遷移（UX）
        runtime.handoffTimer = setTimeout(() => {
          handoffToNextPage();
        }, 1200);
      }catch(_){
        // 失敗しても遷移はする
        if (statusEl) statusEl.innerHTML = `<div class="tiny">（通信が不安定ですが次へ進みます）</div>`;
        runtime.handoffTimer = setTimeout(() => {
          handoffToNextPage();
        }, 1200);
      }
    })();
  }
}
</script>
</body>
</html>
