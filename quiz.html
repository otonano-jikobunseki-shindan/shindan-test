<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>大人の診断テスト</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --muted:#93a4c7; --text:#eaf0ff;
      --accent:#7c3aed; --accent2:#22c55e; --danger:#ef4444; --line:#243055;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;background:linear-gradient(180deg,#0b1020,#070a14);color:var(--text);}
    a{color:inherit}
    .wrap{max-width:760px;margin:0 auto;padding:18px 14px 40px;}
    .hero{padding:18px 16px;border:1px solid var(--line);border-radius:16px;background:rgba(18,26,51,.72);backdrop-filter: blur(8px);}
    h1{font-size:22px;margin:0 0 8px;}
    .sub{color:var(--muted);line-height:1.6;margin:0}
    .card{margin-top:14px;padding:16px;border:1px solid var(--line);border-radius:16px;background:rgba(18,26,51,.72);}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{
      appearance:none;border:1px solid var(--line);background:#0f1733;color:var(--text);
      padding:12px 14px;border-radius:12px;font-weight:700;cursor:pointer;flex:1;min-width:140px;
    }
    .btn:hover{border-color:#3b4a7a}
    .btn.primary{background:linear-gradient(90deg,var(--accent),#4f46e5);border-color:transparent;}
    .btn.good{background:linear-gradient(90deg,var(--accent2),#16a34a);border-color:transparent;}
    .btn.ghost{background:transparent}
    .btn.danger{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .label{font-size:12px;color:var(--muted);margin:0 0 8px}
    .progress{height:10px;background:#0a0f22;border:1px solid var(--line);border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#22c55e);transition:width .25s}
    .qtitle{font-size:16px;font-weight:800;margin:0 0 10px;line-height:1.5}
    .opt{display:block;width:100%;text-align:left;margin:10px 0;padding:12px 12px;border-radius:12px;border:1px solid var(--line);background:#0f1733;color:var(--text);cursor:pointer}
    .opt:hover{border-color:#3b4a7a}
    .opt.selected{outline:2px solid rgba(124,58,237,.55)}
    .tiny{font-size:12px;color:var(--muted);line-height:1.6}
    .field{width:100%;padding:12px;border-radius:12px;border:1px solid var(--line);background:#0f1733;color:var(--text);font-size:16px}
    select.field{appearance:auto;}
    .hr{height:1px;background:var(--line);margin:14px 0}
    .pill{display:inline-block;padding:6px 10px;border:1px solid var(--line);border-radius:999px;color:var(--muted);font-size:12px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .err{color:#fecaca;background:rgba(239,68,68,.10);border:1px solid rgba(239,68,68,.35);padding:10px;border-radius:12px;margin-top:10px}
    .ok{color:#bbf7d0;background:rgba(34,197,94,.10);border:1px solid rgba(34,197,94,.35);padding:10px;border-radius:12px;margin-top:10px}
    .mutedBox{border:1px dashed var(--line);border-radius:12px;padding:10px;color:var(--muted);line-height:1.7}

    /* 10問表示用 */
    .qblock{border:1px solid var(--line);border-radius:14px;padding:12px;margin:12px 0;background:#0c1230}
    .qhead{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px;flex-wrap:wrap}
    .qnum{font-weight:800}
    .qopt{margin:8px 0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>あなたの特性が笑っちゃうほどわかる！大人の診断テスト！</h1>
      <p class="sub">5分以内で回答できる！現在、完全無料で診断できます。</p>
      <p class="sub tiny">※このページはスマホ前提で作っていますが、PCでも表示可能です。</p>
    </div>

    <div id="app" class="card"></div>

    <div class="card">
      <div class="label">デバッグ表示（必要なときだけ見る用）</div>
      <div class="mutedBox tiny">
        sessionId: <span id="dbgSid" class="mono"></span><br/>
        step: <span id="dbgStep" class="mono"></span>
      </div>
    </div>
  </div>

<script>
/* =========================
   Config
========================= */
const GAS_URL = "https://script.google.com/macros/s/AKfycbz0nSbcIZKV6P3d8NPu1mZKRjVLT2EF6grR5nfc2otxiky6jdaRBiFhskvjoemWUlOn/exec";
const NEXT_PAGE_URL = "result.html";

// ★GASは今のまま維持：logAnswer を使い続ける
const ACTIONS = { LOG: "logAnswer" };

const TSV_PATH = {
  male: "data/male_questions.tsv",
  female: "data/female_questions.tsv",
  mbti: "data/mbti_options.tsv"
};

// ★10問ずつ
const PAGE_SIZE = 10;

const LS = {
  gender: "diag_gender",
  sid: "diag_sid",
  answers: "diag_answers",
  progress: "diag_progress",
  // 送信管理
  sent: "diag_sent",          // 送信済みqid一覧
  queue: "diag_queue_state",  // キュー状態（未送信配列など）
};

let runtime = {
  step: "landing",
  sid: "",
  gender: "",
  questions: [],
  // idx は「次に表示する開始index（0,10,20...）」として使う
  idx: 0,
  answers: {},
  mbtiOptions: null,

  // 送信管理
  sentMap: {},          // { Q1:true, Q2:true ... }（サーバへ送ったか）
  pendingOrder: [],     // 未送信qidの順序（キュー）
  inflight: false,      // 送信中ロック
};

const $app = document.getElementById("app");
const $dbgSid = document.getElementById("dbgSid");
const $dbgStep = document.getElementById("dbgStep");

/* =========================
   Utils
========================= */
function setStep(step){ runtime.step = step; render(); }
function escapeHTML(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function nowISO(){ return new Date().toISOString(); }
function newSessionId(){
  if (crypto?.randomUUID) return crypto.randomUUID();
  return "sid_" + Date.now() + "_" + Math.random().toString(16).slice(2);
}
function optStr(n){ return "OPT" + String(n); }
function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

/* =========================
   LocalStorage
========================= */
function loadLS(){
  const sid = localStorage.getItem(LS.sid);
  const gender = localStorage.getItem(LS.gender);
  const answersRaw = localStorage.getItem(LS.answers);
  const progressRaw = localStorage.getItem(LS.progress);
  const sentRaw = localStorage.getItem(LS.sent);
  const queueRaw = localStorage.getItem(LS.queue);

  if (sid) runtime.sid = sid;
  if (gender) runtime.gender = gender;

  if (answersRaw){
    try{ runtime.answers = JSON.parse(answersRaw) || {}; }catch(_){}
  }
  if (progressRaw){
    try{
      const p = JSON.parse(progressRaw) || {};
      runtime.idx = Number(p.idx || 0);
    }catch(_){}
  }

  if (sentRaw){
    try{ runtime.sentMap = JSON.parse(sentRaw) || {}; }catch(_){}
  }
  if (queueRaw){
    try{
      const q = JSON.parse(queueRaw) || {};
      runtime.pendingOrder = Array.isArray(q.pendingOrder) ? q.pendingOrder : [];
    }catch(_){}
  }
}

function saveLS(){
  localStorage.setItem(LS.sid, runtime.sid);
  localStorage.setItem(LS.gender, runtime.gender);
  localStorage.setItem(LS.answers, JSON.stringify(runtime.answers || {}));
  localStorage.setItem(LS.progress, JSON.stringify({ idx: runtime.idx, savedAt: nowISO() }));
  localStorage.setItem(LS.sent, JSON.stringify(runtime.sentMap || {}));
  localStorage.setItem(LS.queue, JSON.stringify({ pendingOrder: runtime.pendingOrder || [], savedAt: nowISO() }));
}

function clearLSForRestart(){
  localStorage.removeItem(LS.gender);
  localStorage.removeItem(LS.sid);
  localStorage.removeItem(LS.answers);
  localStorage.removeItem(LS.progress);
  localStorage.removeItem(LS.sent);
  localStorage.removeItem(LS.queue);
}

/* =========================
   TSV
========================= */
async function loadTSV(path){
  const res = await fetch(path, { cache:"no-store" });
  if (!res.ok) throw new Error(`TSV読込に失敗: ${path}`);
  const text = await res.text();
  return parseTSV(text);
}

function parseTSV(tsv){
  const lines = tsv.replace(/\r/g,"").split("\n").filter(l => l.trim() !== "");
  if (lines.length < 2) return [];
  const rawHeader = lines[0].split("\t").map(s=>s.trim());
  const header = rawHeader.map((h, i) => h !== "" ? h : `__col${i}`);

  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split("\t");
    const obj = {};
    for (let c=0;c<header.length;c++){
      obj[header[c]] = (cols[c] ?? "").trim();
    }
    rows.push(obj);
  }
  return rows;
}

/* =========================
   GAS POST (existing)
========================= */
async function postGAS(payload){
  const body = new URLSearchParams();
  body.set("payload", JSON.stringify(payload));

  const res = await fetch(GAS_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
    body
  });

  const text = await res.text();
  let json;
  try { json = JSON.parse(text); }
  catch { throw new Error("GAS応答がJSONではありません: " + text.slice(0,200)); }
  return json;
}

/* =========================
   Handoff
========================= */
function handoffToNextPage(){
  const sid = encodeURIComponent(runtime.sid || "");
  const gender = encodeURIComponent(runtime.gender || "");
  const url = `${NEXT_PAGE_URL}?sid=${sid}&gender=${gender}`;
  location.replace(url);
}

/* =========================
   MBTI helpers (same)
========================= */
function normalizeMbtiType(type){
  const t = String(type || "").toUpperCase().replace(/[^EISNTFJP]/g,"");
  return (t.length === 4) ? t : "";
}
function inferMbtiAxesFromType(type){
  const t = normalizeMbtiType(type);
  if (!t) return {MBTI1:"",MBTI2:"",MBTI3:"",MBTI4:""};
  return {MBTI1:t[0], MBTI2:t[1], MBTI3:t[2], MBTI4:t[3]};
}
async function loadMbtiOptions(){
  const rows = await loadTSV(TSV_PATH.mbti);
  const opts = [];
  for (const r of rows){
    const label = (r["表示名"] || r["表示"] || r["Label"] || r["__col0"] || "").trim();
    if (!label) continue;

    const m = label.match(/^([EI][SN][TF][JP])/i);
    if (!m) continue;
    const type = normalizeMbtiType(m[1]);
    if (!type) continue;

    const axes = {
      MBTI1: (r.MBTI1 || "").trim(),
      MBTI2: (r.MBTI2 || "").trim(),
      MBTI3: (r.MBTI3 || "").trim(),
      MBTI4: (r.MBTI4 || "").trim(),
    };
    const inferred = inferMbtiAxesFromType(type);

    opts.push({
      label,
      type,
      MBTI1: axes.MBTI1 || inferred.MBTI1,
      MBTI2: axes.MBTI2 || inferred.MBTI2,
      MBTI3: axes.MBTI3 || inferred.MBTI3,
      MBTI4: axes.MBTI4 || inferred.MBTI4,
    });
  }

  const seen = new Set();
  const uniq = [];
  for (const o of opts){
    if (seen.has(o.type)) continue;
    seen.add(o.type);
    uniq.push(o);
  }
  return uniq;
}

/* =========================
   Init
========================= */
async function init(){
  loadLS();
  if (!runtime.sid) runtime.sid = newSessionId();
  runtime.step = "landing";
  render();
}
init();

/* =========================
   Render router
========================= */
function render(){
  $dbgSid.textContent = runtime.sid || "";
  $dbgStep.textContent = runtime.step || "";

  if (runtime.step === "landing") return renderLanding();
  if (runtime.step === "gender") return renderGender();
  if (runtime.step === "quiz") return renderQuiz10();
  if (runtime.step === "mbti") return renderMbti();
  if (runtime.step === "handoff") return renderHandoff();
}

/* =========================
   Landing / Gender (mostly same)
========================= */
function renderLanding(){
  const hasProgress = !!(runtime.gender && (runtime.idx > 0 || Object.keys(runtime.answers||{}).length > 0));

  $app.innerHTML = `
    <div class="label">まずはスタート</div>
    <p class="sub">いくつかの質問に答えるだけで、あなたの傾向をスパッと整理します。</p>
    <div class="hr"></div>

    ${hasProgress ? `
      <div class="mutedBox tiny" style="margin-bottom:10px;">
        途中保存データが見つかりました。続きから再開できます。
      </div>
      <div class="row">
        <button class="btn primary" id="btnResume">続きから再開</button>
        <button class="btn danger" id="btnNewStart">最初から</button>
      </div>
    ` : `
      <button class="btn primary" id="btnStart">診断をはじめる</button>
    `}

    <p class="tiny" style="margin-top:10px;">
      ※このページ（quiz.html）は「回答送信→次ページへ引き継ぎ」まで担当します。<br/>
      ※結果の表示は次のページで行ってください。
    </p>
  `;

  if (!hasProgress){
    document.getElementById("btnStart").onclick = () => setStep("gender");
    return;
  }

  document.getElementById("btnResume").onclick = async () => {
    try{
      runtime.questions = await loadTSV(runtime.gender === "male" ? TSV_PATH.male : TSV_PATH.female);
      // idx は 0,10,20... に丸める
      runtime.idx = Math.floor((runtime.idx || 0) / PAGE_SIZE) * PAGE_SIZE;
      saveLS();
      setStep("quiz");
      // 再開時も送信キューを回す（未送信があれば勝手に送る）
      pumpSendQueue_();
    }catch(err){
      $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
        <div class="hr"></div>
        <button class="btn ghost" id="back">戻る</button>`;
      document.getElementById("back").onclick = () => setStep("landing");
    }
  };

  document.getElementById("btnNewStart").onclick = () => {
    if (!confirm("保存データを破棄して最初からにしますか？")) return;
    hardReset_();
  };
}

function renderGender(){
  $app.innerHTML = `
    <div class="label">質問 0 / 性別</div>
    <p class="qtitle">あなたはどれですか？</p>
    <div class="row">
      <button class="btn" id="gMale">男性</button>
      <button class="btn" id="gFemale">女性</button>
      <button class="btn" id="gOther">その他</button>
    </div>
    <p class="tiny" style="margin-top:10px;">
      ※「その他」は女性と同じ質問に進みます。<br/>
      ※それ以外の目的で性別を使用しません。
    </p>
    <div class="hr"></div>
    <button class="btn ghost" id="back">戻る</button>
  `;

  document.getElementById("gMale").onclick = () => startQuizWithGender("male");
  document.getElementById("gFemale").onclick = () => startQuizWithGender("female");
  document.getElementById("gOther").onclick = () => startQuizWithGender("female");
  document.getElementById("back").onclick = () => setStep("landing");
}

async function startQuizWithGender(gender){
  runtime.gender = gender;
  runtime.idx = 0;
  runtime.answers = {};
  runtime.questions = [];
  runtime.mbtiOptions = null;

  // 新セッション
  runtime.sid = newSessionId();

  // 送信管理も初期化
  runtime.sentMap = {};
  runtime.pendingOrder = [];
  runtime.inflight = false;

  saveLS();

  try{
    runtime.questions = await loadTSV(gender === "male" ? TSV_PATH.male : TSV_PATH.female);
  }catch(err){
    $app.innerHTML = `<div class="err">TSV読込エラー: ${escapeHTML(err.message)}</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">戻る</button>`;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  setStep("quiz");
}

/* =========================
   Quiz (10 questions per page)
========================= */
function renderQuiz10(){
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;

  if (!qTotal){
    $app.innerHTML = `
      <div class="err">質問データが空です。TSVの中身を確認してください。</div>
      <div class="hr"></div>
      <button class="btn ghost" id="back">性別選択に戻る</button>
    `;
    document.getElementById("back").onclick = () => setStep("gender");
    return;
  }

  if (start >= qTotal){
    // 全部終わり
    $app.innerHTML = `
      <div class="label">回答完了（Q1〜Q${qTotal}）</div>
      <p class="qtitle">おつかれ！最後にMBTI（任意）を聞いて、次へ進みます。</p>
      <div class="mutedBox tiny" style="margin:10px 0;">
        ※未送信が残っている場合はバックグラウンドで送信を継続します。
      </div>
      <button class="btn good" id="btnToMbti">MBTI入力へ進む</button>
      <div id="msg"></div>
    `;
    document.getElementById("btnToMbti").onclick = () => setStep("mbti");
    // 最終ページでも送信回す
    pumpSendQueue_({ statusElId: "msg" });
    return;
  }

  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);

  const answeredCount = countAnswered_();
  const pct = Math.round((answeredCount / qTotal) * 100);

  const pageAnswered = slice.filter(q => {
    const qid = getQid_(q, start);
    return !!runtime.answers[qid];
  }).length;

  $app.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center;">
      <span class="pill">進捗 ${answeredCount} / ${qTotal}</span>
      <span class="pill">今 ${start+1}〜${end} 問目</span>
      <span class="pill">性別: ${runtime.gender === "male" ? "男性" : "女性/その他"}</span>
    </div>

    <div class="progress" style="margin-top:10px;">
      <div class="bar" style="width:${pct}%"></div>
    </div>

    <div class="hr"></div>

    <div class="mutedBox tiny">
      このページは ${PAGE_SIZE}問まとめて回答できます。<br/>
      ローカル保存は即時。送信は「10問たまったら」まとめて行い、通信は同時に走らないよう制御しています。
    </div>

    <div id="qList">
      ${slice.map((q, i) => renderQBlock_(q, start, i)).join("")}
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnPrevPage" ${start===0?'disabled':''}>前の10問</button>
      <button class="btn primary" id="btnNextPage" ${pageAnswered < slice.length ? 'disabled' : ''}>
        次の10問へ
      </button>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn good" id="btnSendNow">今すぐ送信する</button>
      <button class="btn danger" id="btnRestart">最初からやり直す</button>
    </div>

    <p class="tiny" style="margin-top:10px;">
      ※「次の10問へ」は、このページの全問が回答済みで押せます。<br/>
      ※爆速で回答しても送信は1本ずつ（キュー）で処理します。
    </p>

    <div id="msg"></div>
  `;

  // 選択肢クリック
  document.querySelectorAll("[data-qid][data-opt]").forEach(btn => {
    btn.onclick = () => {
      const qid = btn.getAttribute("data-qid");
      const opt = btn.getAttribute("data-opt");
      onAnswer_(qid, opt);
    };
  });

  document.getElementById("btnPrevPage").onclick = () => {
    runtime.idx = clamp(runtime.idx - PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
  };

  document.getElementById("btnNextPage").onclick = () => {
    // ここで“ページ分が埋まってる”の最終チェック
    if (!isPageComplete_(slice, start)) return;
    runtime.idx = clamp(runtime.idx + PAGE_SIZE, 0, qTotal);
    saveLS();
    render();
    // 次ページ表示してても、送信は裏で継続OK
    pumpSendQueue_();
  };

  document.getElementById("btnSendNow").onclick = async () => {
    await pumpSendQueue_({ force: true, statusElId: "msg" });
  };

  document.getElementById("btnRestart").onclick = () => {
    if (!confirm("最初からやり直しますか？")) return;
    hardReset_();
  };

  // 初回描画時に送信キュー回す（未送信があれば勝手に送る）
  pumpSendQueue_({ statusElId: "msg" }).catch(()=>{});
}

function renderQBlock_(q, pageStart, i){
  const idx = pageStart + i;
  const qid = getQid_(q, idx);
  const text = q["質問文"] || q["question"] || q["Question"] || q["質問"] || "";
  const answered = runtime.answers[qid] || "";

  // 選択肢は「10→1」
  const opts = [];
  for (let n=10;n>=1;n--){
    const key = `選択肢${n}`;
    if (q[key] != null && String(q[key]).trim() !== "") {
      opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
    }
  }
  if (!opts.length){
    for (let n=10;n>=1;n--){
      const key = `OPT${n}`;
      if (q[key] != null && String(q[key]).trim() !== "") {
        opts.push({ label: String(q[key]).trim(), opt: optStr(n) });
      }
    }
  }

  const sent = !!runtime.sentMap[qid];
  const sentPill = sent ? `<span class="pill">送信済</span>` : `<span class="pill">未送信</span>`;

  return `
    <div class="qblock" id="block_${escapeHTML(qid)}">
      <div class="qhead">
        <div class="qnum">${escapeHTML(qid)}</div>
        <div class="row" style="gap:6px;flex:0;">
          ${sentPill}
          ${answered ? `<span class="pill">回答済</span>` : `<span class="pill">未回答</span>`}
        </div>
      </div>
      <div class="qtitle">${escapeHTML(text)}</div>
      <div class="qopt">
        ${opts.map(o => {
          const sel = (answered === o.opt);
          return `
            <button class="opt ${sel ? "selected":""}"
              data-qid="${escapeHTML(qid)}"
              data-opt="${escapeHTML(o.opt)}">
              ${escapeHTML(o.label)}
              ${sel ? ' <span class="pill" style="float:right;">選択中</span>' : ''}
            </button>
          `;
        }).join("")}
      </div>
    </div>
  `;
}

function getQid_(q, absoluteIdx){
  return q.QID || q.qid || `Q${absoluteIdx+1}`;
}

function countAnswered_(){
  // Q1..Qn を想定（TSVのQIDがある場合も、それに合わせる）
  // ここは単純に answers のうち "Q" で始まるものを数える
  return Object.keys(runtime.answers || {}).filter(k => /^Q\d+$/.test(k)).length;
}

function isPageComplete_(slice, pageStart){
  for (let i=0;i<slice.length;i++){
    const qid = getQid_(slice[i], pageStart + i);
    if (!runtime.answers[qid]) return false;
  }
  return true;
}

/* =========================
   Answer handling: local save + queue
========================= */
function onAnswer_(qid, opt){
  // 1) ローカル保存即時
  runtime.answers[qid] = opt;

  // 2) 未送信ならキューへ（重複防止）
  if (!runtime.sentMap[qid]){
    if (!runtime.pendingOrder.includes(qid)) runtime.pendingOrder.push(qid);
  }

  saveLS();

  // 3) このページだけ再描画（全部renderだと重いので必要最小限）
  refreshBlockUI_(qid);

  // 4) 次へボタン活性/非活性
  refreshNextButton_();

  // 5) 10問たまったら送信開始（裏で）
  if (runtime.pendingOrder.length >= PAGE_SIZE){
    pumpSendQueue_().catch(()=>{});
  }
}

function refreshBlockUI_(qid){
  const block = document.getElementById("block_" + qid);
  if (!block) { render(); return; } // 念のため
  // ブロックだけ作り直すのは面倒なので、素直にページ再描画（でも10問なので十分軽い）
  render();
}

function refreshNextButton_(){
  const btn = document.getElementById("btnNextPage");
  if (!btn) return;
  const qTotal = runtime.questions.length || 0;
  const start = runtime.idx;
  const end = Math.min(start + PAGE_SIZE, qTotal);
  const slice = runtime.questions.slice(start, end);
  btn.disabled = !isPageComplete_(slice, start);
}

/* =========================
   Send queue (NO concurrent)
   - "10問まとめて送信" = キューから最大10件取り出し
   - ただしGASは既存 logAnswer を使うため、内部で1件ずつ順番にPOST
========================= */
async function pumpSendQueue_(opts={}){
  const force = !!opts.force;
  const statusElId = opts.statusElId || null;

  const statusEl = statusElId ? document.getElementById(statusElId) : null;

  if (runtime.inflight) {
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（送信中…）</div>`;
    return;
  }

  // 送るものがない
  const unsent = runtime.pendingOrder.filter(qid => !runtime.sentMap[qid] && !!runtime.answers[qid]);
  if (unsent.length === 0) {
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（未送信はありません）</div>`;
    return;
  }

  // 10件ずつ
  const batch = force ? unsent.slice(0, PAGE_SIZE) : (unsent.length >= PAGE_SIZE ? unsent.slice(0, PAGE_SIZE) : []);
  if (!force && batch.length === 0){
    // 10件未満は“自動送信しない”（=通信節約）。必要なら「今すぐ送信」で送れる
    if (statusEl) statusEl.innerHTML = `<div class="tiny">（未送信が ${unsent.length} 件あります。10件たまると自動送信します）</div>`;
    return;
  }

  runtime.inflight = true;
  saveLS();

  if (statusEl) statusEl.innerHTML = `<div class="tiny">送信中…（${batch.length}件）</div>`;

  let okCount = 0;
  let failCount = 0;

  for (const qid of batch){
    try{
      const payload = {
        action: ACTIONS.LOG, // ★既存
        sessionId: runtime.sid,
        gender: runtime.gender,
        qid,
        opt: runtime.answers[qid],
        answeredAt: nowISO()
      };

      const r = await postGAS(payload);

      if (r && r.ok){
        runtime.sentMap[qid] = true;
        okCount++;
      } else {
        failCount++;
      }
    }catch(_){
      failCount++;
    }

    // 送れたものは pendingOrder から取り除く（失敗は残す）
    runtime.pendingOrder = runtime.pendingOrder.filter(x => x !== qid || !runtime.sentMap[x]);
    saveLS();
  }

  runtime.inflight = false;
  saveLS();

  if (statusEl){
    if (failCount === 0){
      statusEl.innerHTML = `<div class="ok tiny">送信OK：${okCount}件</div>`;
    } else {
      statusEl.innerHTML = `<div class="err tiny">送信：OK ${okCount}件 / 失敗 ${failCount}件（通信が落ち着いたら「今すぐ送信」で再送できます）</div>`;
    }
  }

  // まだ10件以上溜まってたら続けて送る（自動で連続送信）
  const stillUnsent = runtime.pendingOrder.filter(qid => !runtime.sentMap[qid] && !!runtime.answers[qid]);
  if (stillUnsent.length >= PAGE_SIZE){
    await pumpSendQueue_(opts);
  }
}

function hardReset_(){
  runtime.sid = newSessionId();
  runtime.gender = "";
  runtime.questions = [];
  runtime.idx = 0;
  runtime.answers = {};
  runtime.mbtiOptions = null;
  runtime.sentMap = {};
  runtime.pendingOrder = [];
  runtime.inflight = false;
  clearLSForRestart();
  render();
}

/* =========================
   MBTI view (same, but send via existing logAnswer)
========================= */
function renderMbti(){
  $app.innerHTML = `
    <div class="label">MBTI（任意）</div>
    <p class="qtitle">もし分かれば、MBTIを選んでください（未選択でもOK）。</p>

    <div id="mbtiArea">
      <div class="tiny">候補を読み込み中…</div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <button class="btn ghost" id="btnBackToQuiz">回答を見直す</button>
      <button class="btn good" id="btnNext">送信して次へ</button>
    </div>

    <div id="msg"></div>

    <p class="tiny" style="margin-top:10px;">
      ※プルダウン表示は「ENFP（運動家）」形式です。<br/>
      ※選択すると MBTI1〜4（E/I, S/N, T/F, J/P）も一緒に保存・送信します。
    </p>
  `;

  document.getElementById("btnBackToQuiz").onclick = () => {
    // 最後のページへ戻す
    const qTotal = runtime.questions.length || 0;
    runtime.idx = Math.floor((Math.max(0, qTotal-1)) / PAGE_SIZE) * PAGE_SIZE;
    saveLS();
    setStep("quiz");
  };

  document.getElementById("btnNext").onclick = async () => {
    await saveMbtiAndHandoff();
  };

  (async () => {
    const area = document.getElementById("mbtiArea");
    try{
      if (!runtime.mbtiOptions) runtime.mbtiOptions = await loadMbtiOptions();

      if (!runtime.mbtiOptions || runtime.mbtiOptions.length === 0){
        area.innerHTML = `<div class="err">mbti_options.tsv は読めましたが、候補が0件でした。</div>
          <div class="tiny">（TSVの1列目に「ENFP（運動家）」形式が入っているか確認してください）</div>`;
        return;
      }

      const savedType = normalizeMbtiType(runtime.answers.MBTI || "");
      area.innerHTML = `
        <div class="label">MBTIタイプ</div>
        <select id="mbtiSelect" class="field">
          <option value="">選択しない（分からない）</option>
          ${runtime.mbtiOptions.map(o => `
            <option value="${escapeHTML(o.type)}" ${o.type === savedType ? "selected" : ""}>
              ${escapeHTML(o.label)}
            </option>
          `).join("")}
        </select>
        <div class="tiny" style="margin-top:10px;">
          ※表示は「ENFP（運動家）」、送信は「MBTI=ENFP / MBTI1..4=E N F P」です。
        </div>
      `;
    }catch(err){
      area.innerHTML = `<div class="err">MBTI候補の読込に失敗: ${escapeHTML(err.message)}</div>
        <div class="tiny">※一旦スキップして次へ進めます。</div>`;
    }
  })();
}

async function saveMbtiAndHandoff(){
  const msg = document.getElementById("msg");
  msg.innerHTML = `<div class="tiny">送信準備中…</div>`;

  // まず未送信が残ってたら送っておく（強制）
  await pumpSendQueue_({ force: true, statusElId: "msg" });

  const sel = document.getElementById("mbtiSelect");
  const type = sel ? normalizeMbtiType(sel.value) : "";

  if (type){
    const found = (runtime.mbtiOptions || []).find(o => o.type === type);
    const axes = found ? {
      MBTI1: found.MBTI1 || "",
      MBTI2: found.MBTI2 || "",
      MBTI3: found.MBTI3 || "",
      MBTI4: found.MBTI4 || "",
    } : inferMbtiAxesFromType(type);

    runtime.answers.MBTI = type;
    runtime.answers.MBTI1 = axes.MBTI1;
    runtime.answers.MBTI2 = axes.MBTI2;
    runtime.answers.MBTI3 = axes.MBTI3;
    runtime.answers.MBTI4 = axes.MBTI4;
    saveLS();

    try{
      // ★MBTIだけは従来通り単発送信（GAS側は logAnswer のMBTI分岐でOK）
      const r = await postGAS({
        action: ACTIONS.LOG,
        sessionId: runtime.sid,
        gender: runtime.gender,
        qid: "MBTI",
        opt: type,
        MBTI1: axes.MBTI1,
        MBTI2: axes.MBTI2,
        MBTI3: axes.MBTI3,
        MBTI4: axes.MBTI4,
        answeredAt: nowISO()
      });

      msg.innerHTML = r?.ok
        ? `<div class="ok">MBTIも送信しました。次ページへ移動します。</div>`
        : `<div class="tiny">（MBTIの送信はローカル保存のみで継続）次ページへ移動します。</div>`;
    }catch(_){
      msg.innerHTML = `<div class="tiny">（通信が不安定なのでMBTIはローカル保存のみ）次ページへ移動します。</div>`;
    }
  }else{
    msg.innerHTML = `<div class="tiny">MBTIは未選択のまま次へ進みます。</div>`;
  }

  setTimeout(() => setStep("handoff"), 350);
}

function renderHandoff(){
  $app.innerHTML = `
    <div class="label">送信完了</div>
    <p class="qtitle">次のページへ移動します。</p>
    <div class="mutedBox tiny">
      sessionId を引き継いでいます：<span class="mono">${escapeHTML(runtime.sid)}</span>
    </div>
    <div class="hr"></div>
    <button class="btn primary" id="go">次へ</button>
  `;
  document.getElementById("go").onclick = () => handoffToNextPage();
  setTimeout(() => handoffToNextPage(), 500);
}
</script>
</body>
</html>
